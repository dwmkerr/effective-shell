---
title: 'sourceenv'
---

import ShellwrightRecording from '@site/src/components/ShellwrightRecording';

export const recordingPrompt = `Create a shell recording using shellwright for the sourceenv snippet:

1. Setup (before recording starts):
   - Start shell in: snippets/snippets/sourceenv/project/
   - Set simple PS1: set_ps1 dwmkerr_simple
   - Clear the screen

2. Recording settings:
   - Terminal size: 80x20
   - FPS: 10
   - Use typewriter-style keystroke entry
   - Wait 2 seconds between commands

3. Commands to record:
   - ls -al (show .env files)
   - cat .env (show contents)
   - clear (execute quickly, no typewriter)
   - sourceenv (shows 4 vars set)
   - sourceenv .env.prod (shows 2 updated, 2 new)

4. Save recording to: snippets/snippets/sourceenv/sourceenv.gif`;

# Source Environment Variables

The `sourceenv` function sources environment variables from `.env` files into your current shell session. It's a common need when working with projects that use `.env` files for configuration - rather than manually exporting each variable, just run `sourceenv`:

<ShellwrightRecording
  src={require('./sourceenv.gif').default}
  alt="sourceenv demo"
  prompt={recordingPrompt}
/>

## Usage

```bash
sourceenv              # Source .env in current directory
sourceenv .env.prod    # Source a specific env file
sourceenv -v           # Verbose mode (show values being set)
```

The function shows feedback as it works:
- **set** (green) - new variable added to environment
- **updated** (blue) - existing variable changed

## The Code

```bash title="https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh"
sourceenv() {
  local name="sourceenv"
  local verbose=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h)
        echo "usage: ${name} [-v] [<path_to_env_file>]"
        echo "  Sources environment variable definitions from a .env file, e.g:"
        echo "  KEY=VALUE"
        echo "  -v  verbose mode (show values being set)"
        exit 0
        ;;
      -v)
        verbose=true
        shift
        ;;
      *)
        env_file="$1"
        shift
        ;;
    esac
  done

  # Determine the path to the environment file
  env_file="${env_file:-.env}"

  if [ ! -f "$env_file" ]; then
    echo "error: ${env_file} not found"
    echo "usage: ${name} [-v] [<path_to_env_file>]"
  else
    # Process each line in the env file
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comment lines
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

      # Remove inline comments (but not inside quotes)
      if [[ "$line" =~ ^([^#]*[^[:space:]])([[:space:]]*#.*)?$ ]]; then
        line="${BASH_REMATCH[1]}"
      fi

      # Split on first = sign
      if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
        var_name="${BASH_REMATCH[1]}"
        var_value="${BASH_REMATCH[2]}"

        # Remove surrounding quotes if present
        if [[ "$var_value" =~ ^\"(.*)\"$ ]] || [[ "$var_value" =~ ^\'(.*)\'$ ]]; then
          var_value="${BASH_REMATCH[1]}"
        fi

        # Check if variable already exists and show status
        if [[ -n "${!var_name:-}" ]]; then
          if [[ "$verbose" == true ]]; then
            echo -e "\033[34m${var_name}\033[0m: updated ($var_value)"
          else
            echo -e "\033[34m${var_name}\033[0m: updated"
          fi
        else
          if [[ "$verbose" == true ]]; then
            echo -e "\033[32m${var_name}\033[0m: set ($var_value)"
          else
            echo -e "\033[32m${var_name}\033[0m: set"
          fi
        fi

        # Set the variable
        export "${var_name}=${var_value}"
      fi
    done < "$env_file"
  fi
}
```

## How It Works

- **Skips comments and empty lines** - lines starting with `#` or whitespace are ignored
- **Handles inline comments** - `KEY=value # comment` extracts just `value`
- **Removes quotes** - both single and double quotes are stripped from values
- **Color-coded feedback** - green for new variables, blue for updates
- **Verbose mode** - use `-v` to see the actual values being set

## Installation

Add the function to your shell configuration (e.g., `~/.bashrc` or `~/.zshrc`), or if you use a dotfiles setup, place it in a file that gets sourced on shell startup.

The latest version is available in my [dotfiles](https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh).
