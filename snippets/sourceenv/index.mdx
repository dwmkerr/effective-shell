---
title: 'sourceenv'
---

import ShellwrightRecording from '@site/src/components/ShellwrightRecording';

# Source Environment Variables

The `sourceenv` function sources environment variables from `.env` files into your current shell session. These `.env` files are commonly used in software engineering projects to keep track of environment variables. You might see `.env.example` showing you what values you should set ([like this](https://github.com/mckinsey/agents-at-scale-ark/blob/main/services/ark-api/.env.example)) and then instruct users to copy this file to `.env` and fill with the real values - this file is then normally git ignored.

Many services and tools will read these files by default (there are libraries for [node](https://www.npmjs.com/package/dotenv), [python](https://pypi.org/project/python-dotenv/) and [almost anything else](https://github.com/search?q=dotenv&type=repositories)). The `sourceenv` snippet works in a very similar way - it simply sets these values in your current shell session.


<ShellwrightRecording src={require('./sourceenv.gif').default} alt="sourceenv demo">

**Create a shell recording using shellwright for the sourceenv snippet:**

1. **Setup** (before recording starts):
   - Start shell in: `snippets/snippets/sourceenv/project/`
   - Set simple PS1: `set_ps1 dwmkerr_simple`
   - Clear the screen

2. **Recording settings:**
   - Terminal size: 80x20
   - FPS: 10
   - Use typewriter-style keystroke entry
   - Wait 2 seconds between commands

3. **Commands to record:**
   - `ls -al` (show .env files)
   - `cat .env` (show contents)
   - `clear` (execute quickly, no typewriter)
   - `sourceenv` (shows 4 vars set)
   - `sourceenv .env.prod` (shows 2 updated, 2 new)

4. **Save recording to:** `snippets/snippets/sourceenv/sourceenv.gif`

</ShellwrightRecording>

You can run `sourceenv` like so:

```bash
# Just source whatever is in .env in the current directory.
sourceenv

# Source a specific file.
sourceenv .env.prod

# Source in verbose mode, which shows the actual values being set. Use with
# caution as this will write what might be sensitive values to stdout.
sourceenv -v
```

The function shows feedback as it works:

![sourceenv output](./sourceenv-prod.png)

## The Code

Find the original code in my [dotfiles](https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh). It is shown below with much more extensive documentation and explanation!

```bash title="https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh"
sourceenv() {
  local name="sourceenv"
  local verbose=false

  # Parse the command line arguments using a case statement.
  # Read more in the chapter "Shell Script Essentials".
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h)
        echo "usage: ${name} [-v] [<path_to_env_file>]"
        echo "  Sources environment variable definitions from a .env file, e.g:"
        echo "  KEY=VALUE"
        echo "  -v  verbose mode (show values being set)"
        exit 0
        ;;
      -v)
        verbose=true
        shift
        ;;
      *)
        env_file="$1"
        shift
        ;;
    esac
  done

  # Default to '.env' in the current directory if no file was specified.
  # Read more in the chapter "Variables, Reading Input, and Mathematics".
  env_file="${env_file:-.env}"

  if [ ! -f "$env_file" ]; then
    echo "error: ${env_file} not found"
    echo "usage: ${name} [-v] [<path_to_env_file>]"
  else
    # Read the file line-by-line. The '|| [ -n "$line" ]' ensures we process
    # the last line even if it doesn't end with a newline.
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and lines that start with a comment.
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

      # Strip inline comments. The regex captures everything before a '#' that
      # isn't followed by quoted content.
      if [[ "$line" =~ ^([^#]*[^[:space:]])([[:space:]]*#.*)?$ ]]; then
        line="${BASH_REMATCH[1]}"
      fi

      # Match lines that look like 'KEY=value'. The regex ensures the variable
      # name starts with a letter or underscore.
      if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
        var_name="${BASH_REMATCH[1]}"
        var_value="${BASH_REMATCH[2]}"

        # Strip surrounding quotes (single or double) from the value.
        if [[ "$var_value" =~ ^\"(.*)\"$ ]] || [[ "$var_value" =~ ^\'(.*)\'$ ]]; then
          var_value="${BASH_REMATCH[1]}"
        fi

        # Show the user whether we're setting a new variable or updating an
        # existing one. The '${!var_name:-}' syntax checks if the variable is
        # already set. Blue for updates, green for new variables.
        # Read more in the chapter "Customising Your Command Prompt".
        if [[ -n "${!var_name:-}" ]]; then
          if [[ "$verbose" == true ]]; then
            echo -e "\033[34m${var_name}\033[0m: updated ($var_value)"
          else
            echo -e "\033[34m${var_name}\033[0m: updated"
          fi
        else
          if [[ "$verbose" == true ]]; then
            echo -e "\033[32m${var_name}\033[0m: set ($var_value)"
          else
            echo -e "\033[32m${var_name}\033[0m: set"
          fi
        fi

        # Export the variable so it's available to child processes.
        export "${var_name}=${var_value}"
      fi
    done < "$env_file"
  fi
}
```

## Installation

Add the function to your shell configuration (e.g., `~/.bashrc` or `~/.zshrc`), or if you use a dotfiles setup, place it in a file that gets sourced on shell startup.

The latest version is available in my [dotfiles](https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh).
