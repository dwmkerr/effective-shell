---
title: 'sourceenv'
---

import ShellwrightRecording from '@site/src/components/ShellwrightRecording';

# Source Environment Variables

The `sourceenv` function sources environment variables from `.env` files into your current shell session. These `.env` files are commonly used in software engineering projects to keep track of environment variables. You might see `.env.example` showing you what values you should set ([like this](https://github.com/mckinsey/agents-at-scale-ark/blob/main/services/ark-api/.env.example)) and then instruct users to copy this file to `.env` and fill with the real values - this file is then normally git ignored.

Many services and tools will read these files by default (there are libraries for [node](https://www.npmjs.com/package/dotenv), [python](https://pypi.org/project/python-dotenv/) and [almost anything else](https://github.com/search?q=dotenv&type=repositories)). The `sourceenv` snippet works in a very similar way - it simply sets these values in your current shell session.


<ShellwrightRecording src={require('./sourceenv.gif').default} alt="sourceenv demo">

**Create a shell recording using shellwright for the sourceenv snippet:**

1. **Setup** (before recording starts):
   - Start shell in: `snippets/snippets/sourceenv/project/`
   - Set simple PS1: `set_ps1 dwmkerr_simple`
   - Clear the screen

2. **Recording settings:**
   - Terminal size: 80x20
   - FPS: 10
   - Use typewriter-style keystroke entry
   - Wait 2 seconds between commands

3. **Commands to record:**
   - `ls -al` (show .env files)
   - `cat .env` (show contents)
   - `clear` (execute quickly, no typewriter)
   - `sourceenv` (shows 4 vars set)
   - `sourceenv .env.prod` (shows 2 updated, 2 new)

4. **Save recording to:** `snippets/snippets/sourceenv/sourceenv.gif`

</ShellwrightRecording>

You can run `sourceenv` like so:

```bash
# Just source whatever is in .env in the current directory.
sourceenv

# Source a specific file.
sourceenv .env.prod

# Source in verbose mode, which shows the actual values being set. Use with
# caution as this will write what might be sensitive values to stdout.
sourceenv -v
```

The function shows feedback as it works:

![sourceenv output](./sourceenv-prod.png)

## The Code

Find the original code in my [dotfiles](https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh). It is shown below with much more extensive documentation and explanation!

```bash title="https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh"
sourceenv() {
  local name="sourceenv"
  local verbose=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h)
        echo "usage: ${name} [-v] [<path_to_env_file>]"
        echo "  Sources environment variable definitions from a .env file, e.g:"
        echo "  KEY=VALUE"
        echo "  -v  verbose mode (show values being set)"
        exit 0
        ;;
      -v)
        verbose=true
        shift
        ;;
      *)
        env_file="$1"
        shift
        ;;
    esac
  done

  # Determine the path to the environment file
  env_file="${env_file:-.env}"

  if [ ! -f "$env_file" ]; then
    echo "error: ${env_file} not found"
    echo "usage: ${name} [-v] [<path_to_env_file>]"
  else
    # Process each line in the env file
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comment lines
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

      # Remove inline comments (but not inside quotes)
      if [[ "$line" =~ ^([^#]*[^[:space:]])([[:space:]]*#.*)?$ ]]; then
        line="${BASH_REMATCH[1]}"
      fi

      # Split on first = sign
      if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
        var_name="${BASH_REMATCH[1]}"
        var_value="${BASH_REMATCH[2]}"

        # Remove surrounding quotes if present
        if [[ "$var_value" =~ ^\"(.*)\"$ ]] || [[ "$var_value" =~ ^\'(.*)\'$ ]]; then
          var_value="${BASH_REMATCH[1]}"
        fi

        # Check if variable already exists and show status
        if [[ -n "${!var_name:-}" ]]; then
          if [[ "$verbose" == true ]]; then
            echo -e "\033[34m${var_name}\033[0m: updated ($var_value)"
          else
            echo -e "\033[34m${var_name}\033[0m: updated"
          fi
        else
          if [[ "$verbose" == true ]]; then
            echo -e "\033[32m${var_name}\033[0m: set ($var_value)"
          else
            echo -e "\033[32m${var_name}\033[0m: set"
          fi
        fi

        # Set the variable
        export "${var_name}=${var_value}"
      fi
    done < "$env_file"
  fi
}
```

## How It Works

The code above is extensively commented to explain each step. To learn more about the shell techniques used, check out these chapters from the book:

- [Variables, Reading Input, and Mathematics](/part-3-manipulating-text/variables-reading-input-and-mathematics/) - how shell variables and parameter expansion work
- [Shell Script Essentials](/part-4-shell-scripting/shell-script-essentials/) - functions, conditionals, and loops
- [Customising Your Command Prompt](/part-5-building-your-toolkit/customising-your-command-prompt/) - ANSI escape codes for colored output

## Installation

Add the function to your shell configuration (e.g., `~/.bashrc` or `~/.zshrc`), or if you use a dotfiles setup, place it in a file that gets sourced on shell startup.

The latest version is available in my [dotfiles](https://github.com/dwmkerr/dotfiles/blob/main/shell.functions.d/sourceenv.sh).
