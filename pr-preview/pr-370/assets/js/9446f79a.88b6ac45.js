"use strict";(self.webpackChunkeffective_shell=self.webpackChunkeffective_shell||[]).push([[5368],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>p});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),h=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=h(a),g=i,p=d["".concat(l,".").concat(g)]||d[g]||c[g]||o;return a?n.createElement(p,r(r({ref:t},m),{},{components:a})):n.createElement(p,r({ref:t},m))}));function p(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,r[1]=s;for(var h=2;h<o;h++)r[h]=a[h];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},4859:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var n=a(7462),i=(a(7294),a(3905));const o={title:"Controlling Changes with Git",slug:"/part-5-building-your-toolkit/controlling-changes-with-git"},r=void 0,s={unversionedId:"building-your-toolkit/controlling-changes-with-git/index",id:"building-your-toolkit/controlling-changes-with-git/index",title:"Controlling Changes with Git",description:"Git is an extremely popular version control tool. You can use Git to track changes to text, code, or any type of files you might be working with. Many popular projects use Git as a tool to manage changes, allow others to contribute and collaborate, and to publish their projects.",source:"@site/docs/05-building-your-toolkit/27-controlling-changes-with-git/index.md",sourceDirName:"05-building-your-toolkit/27-controlling-changes-with-git",slug:"/part-5-building-your-toolkit/controlling-changes-with-git",permalink:"/part-5-building-your-toolkit/controlling-changes-with-git",draft:!1,editUrl:"https://github.com/dwmkerr/effective-shell/edit/main/docs/05-building-your-toolkit/27-controlling-changes-with-git/index.md",tags:[],version:"current",frontMatter:{title:"Controlling Changes with Git",slug:"/part-5-building-your-toolkit/controlling-changes-with-git"},sidebar:"sidebar",previous:{title:"Managing your Dotfiles",permalink:"/part-5-building-your-toolkit/managing-your-dotfiles"},next:{title:"Managing Remote Git Repositories and Sharing Your Dotfiles",permalink:"/part-5-building-your-toolkit/managing-rempte-git-repositories/"}},l={},h=[{value:"What is Git",id:"what-is-git",level:2},{value:"Creating a Git Repository",id:"creating-a-git-repository",level:2},{value:"Adding and Resetting Changes to the Index",id:"adding-and-resetting-changes-to-the-index",level:2},{value:"Committing Changes",id:"committing-changes",level:2},{value:"Commit Messages",id:"commit-messages",level:3},{value:"Creating Branches",id:"creating-branches",level:2},{value:"Merging",id:"merging",level:2},{value:"Merging Diverged Branches",id:"merging-diverged-branches",level:3},{value:"The Git Log",id:"the-git-log",level:3},{value:"Merge Conflicts",id:"merge-conflicts",level:3},{value:"Other Merge Strategies",id:"other-merge-strategies",level:3},{value:"Deleting and Renaming Files",id:"deleting-and-renaming-files",level:2},{value:"Restoring Your Working Tree",id:"restoring-your-working-tree",level:2},{value:"Summary",id:"summary",level:2}],m={toc:h};function d(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Git is an extremely popular version control tool. You can use Git to track changes to text, code, or any type of files you might be working with. Many popular projects use Git as a tool to manage changes, allow others to contribute and collaborate, and to publish their projects."),(0,i.kt)("p",null,"In this chapter we'll look at the most common operations for Git to allow us to quickly and easily work with Git repositories. We'll learn Git on the command line by taking our 'dotfiles' folder (a simple set of shell configuration files) and showing how we can track and manage changes."),(0,i.kt)("p",null,"Being able to use Git from the command line is essential to being an effective shell user. In this chapter we'll look at setting up a local Git repository - in the next chapter we'll see how to share it online with the popular GitHub website."),(0,i.kt)("h2",{id:"what-is-git"},"What is Git"),(0,i.kt)("p",null,"Any files or folders that we work with over time, such as our 'dotfiles' (i.e. our personal configuration files) will change. Sometimes new files get added, old files get deleted, files get changed, things get moved around and so on."),(0,i.kt)("p",null,"Git is a ",(0,i.kt)("em",{parentName:"p"},"version control system")," that allows you to track changes to files and folders. This means that you can maintain a history of all of the changes that have been made, when they were made, who made them and why. You can also maintain multiple 'branches' of your files and folders - these branches can be used as working environments where you can make changes, without affecting the current 'main' set of files."),(0,i.kt)("p",null,'Git was written by Linus Torvalds (the creator of Linux) in 2006. "Git" is slang for an annoying person - Linus joked that he always names projects after himself, first Linux and now Git. There were many version control systems around before Git, such as ',(0,i.kt)("em",{parentName:"p"},"CVS")," (Concurrent Version System) and ",(0,i.kt)("em",{parentName:"p"},"SVN")," (Subversion, an system similar to CVS but with some improvements). There were also a number of proprietary and commercial solutions."),(0,i.kt)("p",null,"In recent years Git has become without a doubt the most popular version control system globally, and many highly popular software collaboration systems such as GitHub, GitLab and BitBucket use Git as their underlying version control system, adding additional features on top."),(0,i.kt)("h2",{id:"creating-a-git-repository"},"Creating a Git Repository"),(0,i.kt)("p",null,"All of the information about a set of files or folders that you are tracking the changes for is stored in a ",(0,i.kt)("em",{parentName:"p"},"Git repository"),". We can create a Git repository by running the ",(0,i.kt)("inlineCode",{parentName:"p"},"git init")," (",(0,i.kt)("em",{parentName:"p"},"initialise Git repository"),")"," command."),(0,i.kt)("p",null,"Let's see this in action be creating a Git repository to track changes to our 'dotfiles' folder. Our 'dotfiles' folder is a folder where we keep simple shell configuration - you can read about how to create a folder like this in ",(0,i.kt)("a",{parentName:"p",href:"../../part-5-building-your-toolkit/managing-your-dotfiles"},"Chapter 27 - Managing Your Dotfiles")," or you can download the Effective Shell samples to get a copy of the 'dotfiles' folder."),(0,i.kt)("admonition",{title:"Downloading the Samples",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Run the following command in your shell to download the samples:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"curl effective.sh | sh\n"))),(0,i.kt)("p",null,"If you have installed the samples, you can copy the ",(0,i.kt)("em",{parentName:"p"},"~/effective-shell/dotfiles")," folder to your home directory - this is where we will create our Git repository and start using the Git commands:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ cp -r ~/effective-shell/dotfiles ~/dotfiles\n$ cd ~/dotfiles\n")),(0,i.kt)("p",null,"We have created the ",(0,i.kt)("em",{parentName:"p"},"~/dotfiles")," folder in our home directory from the samples and moved into it."),(0,i.kt)("p",null,"Now we will initialise a Git repository with the ",(0,i.kt)("inlineCode",{parentName:"p"},"git init")," command, and choose a 'branch' name with the ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git init\nInitialized empty Git repository in /home/dwmkerr/dotfiles/.git/\n$ git checkout -b main\n")),(0,i.kt)("p",null,"We'll see the ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," command in detail soon. For now it is enough to know that we have initialised a new Git repository and chosen the name of our 'main' branch."),(0,i.kt)("admonition",{title:"Initialising a Git Repository with a Branch Name",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you are using Git 2.2 or later, you can initialise a repository and set the branch name with a single command:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ git init -b main\n")),(0,i.kt)("p",{parentName:"admonition"},"If you see the error message ",(0,i.kt)("em",{parentName:"p"},"error: unknown switch 'b'")," then this means that you are using a version of Git that does not have the ",(0,i.kt)("inlineCode",{parentName:"p"},"-b")," (",(0,i.kt)("em",{parentName:"p"},"initial branch name"),") flag (any version of Git lower than 2.2).")),(0,i.kt)("h2",{id:"adding-and-resetting-changes-to-the-index"},"Adding and Resetting Changes to the Index"),(0,i.kt)("p",null,"We now have an empty Git repository. We can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," (",(0,i.kt)("em",{parentName:"p"},"show the working tree status"),") command"," to show some information on the files in the ",(0,i.kt)("em",{parentName:"p"},"working tree"),". The working tree is the folder that we are using Git to track changes for, in our case ",(0,i.kt)("em",{parentName:"p"},"~/dotfiles"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git status\nOn branch main\n\nNo commits yet\n\nUntracked files:\n  (use "git add <file>..." to include in what will be committed)\n        install.sh\n        shell.d/\n        shell.sh\n\nnothing added to commit but untracked files present (use "git add" to track)\n')),(0,i.kt)("p",null,"The first thing that ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," tells us is the name of the ",(0,i.kt)("em",{parentName:"p"},"branch")," we are on. We'll look at branches in detail shortly. The next thing we see is that there are no ",(0,i.kt)("em",{parentName:"p"},"commits")," - commits are sets of changes that we track. Finally, git is telling us that there are three files that are 'untracked'. These are the ",(0,i.kt)("em",{parentName:"p"},"install.sh")," and ",(0,i.kt)("em",{parentName:"p"},"shell.sh")," files as well as the ",(0,i.kt)("em",{parentName:"p"},"shell.d")," folder."),(0,i.kt)("p",null,"If we are going to use Git to track changes to these files, we need to add them to the repository. We can do that with the ",(0,i.kt)("em",{parentName:"p"},"git add")," (",(0,i.kt)("em",{parentName:"p"},"add file contents to index"),") command",":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git add .\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"git add")," command takes a list of file paths. We have used the special ",(0,i.kt)("em",{parentName:"p"},"dot")," folder to represent the entire current directory. Let's take a look at the status again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git status\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use "git rm --cached <file>..." to unstage)\n        new file:   install.sh\n        new file:   shell.d/set_ps1.sh\n        new file:   shell.sh\n')),(0,i.kt)("p",null,"Git is now telling us that we have three new files which are ready to be ",(0,i.kt)("em",{parentName:"p"},"committed"),". At the moment these files are in the ",(0,i.kt)("em",{parentName:"p"},"index"),". The index, or staging area, is the set of changes that we are preparing to commit. These changes are not yet stored in the repository. When we add files to the index we are 'staging' changes. When we remove changes from the index, we are 'unstaging' changes."),(0,i.kt)("p",null,"Think of the index as a working area where we can build up a set of changes that we would later like to record in the repository. We could add more files to the index before we actually save them to the repository in a commit."),(0,i.kt)("p",null,"If we were to visualise what we've done so far, it would look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram: A diagram showing how the &#39;git add&#39; command tells Git to track changes to items in the working tree and adds them to the index",src:a(9126).Z,width:"1672",height:"1046"})),(0,i.kt)("p",null,"Our ",(0,i.kt)("em",{parentName:"p"},"working tree")," is the folder associated with our Git repository, this is the ",(0,i.kt)("em",{parentName:"p"},"~/dotfiles")," folder. Our ",(0,i.kt)("em",{parentName:"p"},"index")," is initially empty. When we run the ",(0,i.kt)("inlineCode",{parentName:"p"},"git add")," command, we have told Git we want to add three files to the repository. Our 'staging area' has three files in it. Our Git repository does not have any commits recorded yet."),(0,i.kt)("p",null,"What if we realised that we don't want to add one of these files to the repository? To remove a file from the index we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git reset")," (",(0,i.kt)("em",{parentName:"p"},"reset changes"),") command. Let's reset the ",(0,i.kt)("em",{parentName:"p"},"~/dotfiles/shell.d/set_ps1.sh")," file and check the status:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git reset shell.d/set_ps1.sh\n$ git status\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use "git rm --cached <file>..." to unstage)\n        new file:   install.sh\n        new file:   shell.sh\n\nUntracked files:\n  (use "git add <file>..." to include in what will be committed)\n        shell.d/\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"git reset")," command has removed a change from the index - telling Git that we don't want to 'stage' one of the files. Git now tells us there are two files in the index and one that is not tracked."),(0,i.kt)("p",null,"Here's how we can visualise the changes we've made:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram: The &#39;git reset&#39; command removes items from the index",src:a(7878).Z,width:"2060",height:"968"})),(0,i.kt)("p",null,"You can also reset changes by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"git rm --cached")," (",(0,i.kt)("em",{parentName:"p"},"remove changes from index"),") command. However, I think this is a little harder to work with as you have to remember to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"--cached")," flag to tell Git that you are removing from the index and not the repository. We'll see the ",(0,i.kt)("inlineCode",{parentName:"p"},"git rm")," command a little later in the chapter."),(0,i.kt)("p",null,"Remember - at this stage we have not changed a single file! Nothing we have done has changed the content of any of the files in the working tree, and the only thing that has changed in the Git repository is the 'index' - the current set of files that we are 'staging'."),(0,i.kt)("p",null,"Now let's look at how we can commit our changes with the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," command."),(0,i.kt)("h2",{id:"committing-changes"},"Committing Changes"),(0,i.kt)("p",null,"Once we are happy with the set of changes in the index, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," (",(0,i.kt)("em",{parentName:"p"},"record changes to the repository"),") command","."),(0,i.kt)("p",null,"Now run the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git commit \n")),(0,i.kt)("p",null,"At this stage your shell editor will open up, with the text shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\n# Please enter the commit message for your changes. Lines staring\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch main\n#\n# Initial commit\n#\n# Changes to be committed:\n#       new file:   install.sh\n#       new file:   shell.sh\n#\n# Untracked files:\n#       shell.d/\n#\n")),(0,i.kt)("p",null,"The reason you shell editor opens is that the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," command would like you to provide a message describing your changes. Type a short description, such as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"add the 'install' and 'shell' scripts\n# Please enter the commit message for your changes. Lines staring\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch main\n#\n# Initial commit\n#\n# Changes to be committed:\n#       new file:   install.sh\n#       new file:   shell.sh\n#\n# Untracked files:\n#       shell.d/\n#\n")),(0,i.kt)("p",null,"Note that below the cursor there is some information that starts with the ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," hash symbol. This is provided as a convenience - Git is telling you the status of the index. Anything that starts with a hash symbol is a comment and will not be stored in the commit message."),(0,i.kt)("p",null,"Save the file by pressing Ctrl+W and close the editor with Ctrl+X (these are the commands for the ",(0,i.kt)("inlineCode",{parentName:"p"},"nano")," editor, if you are using a different editor use whatever commands are needed to save and close)."),(0,i.kt)("p",null,"When the editor closes you'll see a confirmation below the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git commit\n[main (root-commit) 01e7a10] add the 'install' and 'shell' scripts\n 2 files changed, 90 insertions(+)\n create mode 100755 install.sh\n create mode 100644 shell.sh\n")),(0,i.kt)("p",null,"This message tells us that two files have changed and 90 lines have been added. It also lists the files we have added. At this point we have created our first commit. We can visualise the process we have gone through like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing how &#39;git commit&#39; commits changes to the repository",src:a(9395).Z,width:"2116",height:"1030"})),(0,i.kt)("p",null,"We 'staged' a set of changes and then 'committed' these changes. We now have a single commit in our repository. Our files are ",(0,i.kt)("em",{parentName:"p"},"still")," unchanged, but our Git repository now has a single commit in it that tracks the two files we added."),(0,i.kt)("p",null,"Let's run ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git status\nOn branch main\nUntracked files:\n  (use "git add <file>..." to include in what will be committed)\n        shell.d/\n\nnothing added to commit but untracked files present (use "git add" to track)\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," command tells us we're still on the 'main' branch, and that there is one file which is not tracked. Let's create a second commit by adding this file. When you run the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," command below, enter a message to describe the commit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git add .\n$ git commit\n[main d7e1bb9] add the 'shell.d' folder\n 1 file changed, 228 insertions(+)\n create mode 100644 shell.d/set_ps1.sh\n")),(0,i.kt)("p",null,"We have now created a second commit - our timeline will look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing our second git commit",src:a(8853).Z,width:"2582",height:"1022"})),(0,i.kt)("p",null,"If we run the ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," command one last time we will see that everything in the working tree is tracked in Git:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git status\nOn branch main\nnothing to commit, working tree clean\n")),(0,i.kt)("p",null,"The concepts of the 'index', the 'working tree' and the Git repository itself can take a bit of getting used to! If you have not used Git before and this seems like a lot to take on board, don't worry, people often find Git quite hard at first. As you use it more this will all become familiar and make more sense."),(0,i.kt)("h3",{id:"commit-messages"},"Commit Messages"),(0,i.kt)("p",null,"You can use any text you like for a commit message. However, there are a couple of things that you should bear in mind:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Try to keep the first line to 50 characters or less. This is known as the 'subject' line - keeping this short will make it easier to look through the log of changes later and see what each commit means."),(0,i.kt)("li",{parentName:"ol"},"If you want to add more detail, leave a blank line after the subject line and then include as much text as you like. Common convention is to wrap the text at 80 characters so that it will fit in a typical shell window.")),(0,i.kt)("p",null,"There are many articles available online that suggest conventions for how to write your commit messages. You can explore these as you get more familiar with Git. The only convention I would strongly recommend that you follow is to make sure that your Git message makes sense - it should describe what the change is and ideally why you have made it. It is easy to forget why changes were made after time has passed - writing good commit messages will save you a lot of time in the long run and also make it easier for others to work with your repository!"),(0,i.kt)("p",null,"Now let's take a look at how we can work on changes to our files with ",(0,i.kt)("em",{parentName:"p"},"branches"),"."),(0,i.kt)("h2",{id:"creating-branches"},"Creating Branches"),(0,i.kt)("p",null,"The commits that we have made so far have been on a 'branch' named 'main'. We can create new 'branches' and put commits on them to allow us to make a series of changes that are isolated from each other."),(0,i.kt)("p",null,"We can create branches using the ",(0,i.kt)("inlineCode",{parentName:"p"},"git branch")," (",(0,i.kt)("em",{parentName:"p"},"list, create or delete branches"),") or ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," (",(0,i.kt)("em",{parentName:"p"},"switch branches or restore working tree"),") command",". To show these features in action, we'll create a new branch called ",(0,i.kt)("em",{parentName:"p"},"aliases")," and add some files to it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout -b aliases\nSwitched to a new branch 'aliases'\n$ git status\nOn branch aliases\nnothing to commit, working tree clean\n")),(0,i.kt)("p",null,"We have used the ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," command to 'switch' to another branch. The ",(0,i.kt)("inlineCode",{parentName:"p"},"-b")," (",(0,i.kt)("em",{parentName:"p"},"new branch"),") option tells Git that we want to create a new branch. The ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," command now shows the new branch name when we run it."),(0,i.kt)("p",null,"Let's create a new file which includes an alias for the ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," command, then let's see what ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," tells us about the status of the working tree:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ echo \'alias gs="git status"\' >> ./shell.d/git_aliases.sh\n$ git status\nOn branch aliases\nUntracked files:\n  (use "git add <file>..." to include in what will be committed)\n        shell.d/git_aliases.sh\n\nnothing added to commit but untracked files present (use "git add" to track)\n')),(0,i.kt)("p",null,"Excellent - we have a new file and Git knows that it is not currently tracked. Let's stage this file and then commit it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git add .\n$ git commit -m \"add alias 'gs' for 'git status'\"\n\n[aliases f61369d] add alias 'gs' for 'git status'\n 1 file changed, 1 insertion(+)\n create mode 100644 shell.d/git_aliases.sh\n")),(0,i.kt)("p",null,"In the example above I used the ",(0,i.kt)("inlineCode",{parentName:"p"},"-m")," (",(0,i.kt)("em",{parentName:"p"},"commit message"),") parameter for the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," command, this means my editor will not open up as we've already provided a commit message."),(0,i.kt)("p",null,"We now have a series of commits that looks like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing how &#39;git checkout -b&#39; creates a new branch",src:a(7685).Z,width:"2136",height:"560"})),(0,i.kt)("p",null,"Our new ",(0,i.kt)("em",{parentName:"p"},"~/dotfiles/shell.d/git_aliases.sh")," file has been committed to the ",(0,i.kt)("em",{parentName:"p"},"aliases")," branch."),(0,i.kt)("p",null,"We can switch back to the ",(0,i.kt)("em",{parentName:"p"},"main")," branch at any time with ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout main\nSwitched to branch 'main'\n$ tree\n.\n\u251c\u2500\u2500 install.sh\n\u251c\u2500\u2500 shell.d\n\u2502\xa0\xa0 \u2514\u2500\u2500 set_ps1.sh\n\u2514\u2500\u2500 shell.sh\n")),(0,i.kt)("p",null,"When we switch back to the ",(0,i.kt)("em",{parentName:"p"},"main")," branch and look at our working tree we can see that the ",(0,i.kt)("em",{parentName:"p"},"git_aliases.sh")," file is not present. This is very cool - by passing the name of the branch we want to switch to as the parameter to the ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," command we can switch branches. If we are on the ",(0,i.kt)("em",{parentName:"p"},"main")," branch we don't see the ",(0,i.kt)("em",{parentName:"p"},"git_aliases.sh")," file, because the commit that added is was not on the ",(0,i.kt)("em",{parentName:"p"},"main")," branch. To go back to the ",(0,i.kt)("em",{parentName:"p"},"aliases")," branch we can just checkout again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout aliases\nSwitched to branch 'aliases'\n$ tree\n.\n\u251c\u2500\u2500 install.sh\n\u251c\u2500\u2500 shell.d\n\u2502\xa0\xa0 \u251c\u2500\u2500 git_aliases.sh\n\u2502\xa0\xa0 \u2514\u2500\u2500 set_ps1.sh\n\u2514\u2500\u2500 shell.sh\n")),(0,i.kt)("p",null,"As a nice little tip, you can always go back to the ",(0,i.kt)("em",{parentName:"p"},"last")," branch you were on by running ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout -")," just like you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"cd -")," to change to the last directory you visited! The dash character is a shortcut for the last branch you were on."),(0,i.kt)("p",null,"Let's add another alias to the file and create another commit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ echo 'alias gcm=\"git checkout main\"' >> ./shell.d/git_aliases.sh\n$ git add .\n$ git commit -m \"add alias 'gcm' for 'git checkout main'\"\n[aliases b9ae0ad] add alias 'gcm' for 'git checkout main'\n 1 file changed, 1 insertion(+)\n")),(0,i.kt)("p",null,"Our branches will now look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing two commits on the &#39;aliases&#39; branch",src:a(7745).Z,width:"2140",height:"552"})),(0,i.kt)("p",null,"You can create as many branches as you like - just remember that when you run ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout -b"),", you branch from the ",(0,i.kt)("em",{parentName:"p"},"current")," branch (and in fact, the current ",(0,i.kt)("em",{parentName:"p"},"HEAD"),", which we will see a little later)."),(0,i.kt)("p",null,"If you want to create a branch, but don't want to switch to it, you can run ",(0,i.kt)("inlineCode",{parentName:"p"},"git branch <new_branch_name>"),". This command will create a branch from your current position, but will not move to it."),(0,i.kt)("h2",{id:"merging"},"Merging"),(0,i.kt)("p",null,"You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git merge")," (",(0,i.kt)("em",{parentName:"p"},"join two or more branches"),") command"," to take the changes from one branch and bring them into another."),(0,i.kt)("p",null,"We can merge the changes from our ",(0,i.kt)("em",{parentName:"p"},"aliases")," branch into the ",(0,i.kt)("em",{parentName:"p"},"main")," branch of the repository by first checking out the branch we want to merge into, and then running ",(0,i.kt)("inlineCode",{parentName:"p"},"git merge"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout main\n$ git merge aliases\nUpdating d7e1bb9..b9ae0ad\nFast-forward\n shell.d/git_aliases.sh | 2 ++\n 1 file changed, 2 insertions(+)\n create mode 100644 shell.d/git_aliases.sh\n")),(0,i.kt)("p",null,"When we run the ",(0,i.kt)("inlineCode",{parentName:"p"},"git merge")," command Git tells us what ",(0,i.kt)("em",{parentName:"p"},"type")," of merge it has performed. In this case we have a ",(0,i.kt)("em",{parentName:"p"},"fast forward")," ","merge, which is the most simple type of merge. When Git tries to merge the two branches, it sees that each of the commits on the ",(0,i.kt)("em",{parentName:"p"},"aliases")," branch can be applied sequentially to the ",(0,i.kt)("em",{parentName:"p"},"main")," branch:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing how Git prepares for a &#39;fast forwards&#39; merge",src:a(8506).Z,width:"2210",height:"492"})),(0,i.kt)("p",null,"One the merge is complete, our branches look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing a fast forward merge result",src:a(4983).Z,width:"2120",height:"364"})),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"main")," branch and ",(0,i.kt)("em",{parentName:"p"},"aliases")," branch contain the exact same set of commits."),(0,i.kt)("p",null,"Let's look at a more common merge scenario - merging branches that have diverged."),(0,i.kt)("h3",{id:"merging-diverged-branches"},"Merging Diverged Branches"),(0,i.kt)("p",null,"Let's create set of commits that show a case where we our branches have ",(0,i.kt)("em",{parentName:"p"},"diverged")," - the branches both have their own new commits:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Create a branch called 'more_aliases', add a file to it, then commit.\ngit checkout -b more_aliases\ntouch ./shell.d/bash_aliases.sh\ngit add .\ngit commit -m \"add a file to store 'bash' aliases\"\n\n# Create another file, add it, then commit.\ntouch ./shell.d/zsh_aliases.sh\ngit add .\ngit commit -m \"add a file to store 'zsh' aliases\"\n")),(0,i.kt)("p",null,"This snippet checks out a new branch called ",(0,i.kt)("em",{parentName:"p"},"more_aliases")," and adds two new empty files, as two separate commits. Now we'll go back to our ",(0,i.kt)("em",{parentName:"p"},"main")," branch and change a file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Go back to the 'main' branch, add and commit another file.\ngit checkout main\necho 'alias gm=\"git merge\"' >> ./shell.d/git_aliases.sh\ngit commit -a -m \"add the 'gm' alias for 'git merge'\"\n")),(0,i.kt)("p",null,"I have added a new alias to the ",(0,i.kt)("em",{parentName:"p"},"shell.d/git_aliases.sh")," file. By adding the ",(0,i.kt)("inlineCode",{parentName:"p"},"-a")," (",(0,i.kt)("em",{parentName:"p"},"all changes"),") flag to the ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," command I was able to add the changes to the index and commit them with a single command."),(0,i.kt)("p",null,"Our branches now look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"A diagram showing two diverged branches",src:a(3763).Z,width:"2136",height:"548"})),(0,i.kt)("p",null,"Let's merge the ",(0,i.kt)("em",{parentName:"p"},"more_aliases")," branch into the ",(0,i.kt)("em",{parentName:"p"},"main")," branch:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git merge more_aliases\n")),(0,i.kt)("p",null,"At this point your shell editor will open up with a request for a commit message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Merge branch 'more_aliases'\n# Please enter a commit message to explain why this merge is needed\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message will abort\n# the commit.\n")),(0,i.kt)("p",null,"Git is going to create a new commit on the ",(0,i.kt)("em",{parentName:"p"},"main")," branch that brings in the changes from the ",(0,i.kt)("em",{parentName:"p"},"bash_aliases")," branch. Because a new commit is going to be created, Git asks us to provide a message. The default message simply explains that this commit merges the branch named ",(0,i.kt)("em",{parentName:"p"},"more_aliases"),"."),(0,i.kt)("p",null,"You can change the message or leave it as is. Save the file when you have entered the message and the output below will be shown:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git merge more_aliases\nMerge made by the 'recursive' strategy.\n shell.d/bash_aliases.sh | 0\n shell.d/zsh_aliases.sh  | 0\n 2 files changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 shell.d/bash_aliases.sh\n create mode 100644 shell.d/zsh_aliases.sh\n")),(0,i.kt)("p",null,"Git now tells us that we have made a ",(0,i.kt)("em",{parentName:"p"},"recursive")," merge and our branches will look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing the results of a recursive merge of two diverged branches",src:a(4876).Z,width:"2352",height:"502"})),(0,i.kt)("p",null,"At this stage both the ",(0,i.kt)("em",{parentName:"p"},"main")," branch and the ",(0,i.kt)("em",{parentName:"p"},"more_aliases")," branch have the full set of changes that we made to ",(0,i.kt)("em",{parentName:"p"},"both")," of the branches. Git merged the two branches together and created a new commit that joins them."),(0,i.kt)("h3",{id:"the-git-log"},"The Git Log"),(0,i.kt)("p",null,"In the diagrams we've shown we've given each commit a number. This was just to make things easier to read - Git doesn't use a number for commits. Git uses a ",(0,i.kt)("em",{parentName:"p"},"SHA"),", which is a hash. A hash is a sequence of letters and numbers that uniquely identify each commit."),(0,i.kt)("p",null,"You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git log")," (",(0,i.kt)("em",{parentName:"p"},"show commit logs"),") command"," to see the log of commits and their SHAs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git log\ncommit 138b40418d5658bc64421e7bcf2680c8339f8350 (HEAD)\nMerge: a95bd90 a51ae1a\nAuthor: Dave Kerr <dwmkerr@gmail.com>\nDate:   Tue Jun 15 21:00:28 2021 +0800\n\n    Merge branch 'more_aliases'\n\ncommit a95bd90e3656b2e55b8708193d387c80c282a6ad\nAuthor: Dave Kerr <dwmkerr@gmail.com>\nDate:   Tue Jun 15 21:00:22 2021 +0800\n\n    add the 'gm' alias for 'git merge'\n\ncommit a51ae1aa42432c2f391ca782c1c20b3793c232ab (more_aliases)\nAuthor: Dave Kerr <dwmkerr@gmail.com>\nDate:   Tue Jun 15 20:53:01 2021 +0800\n\n    add a file to store 'zsh' aliases\n")),(0,i.kt)("p",null,"You can see that the log shows each of the commits, the branch the commit was on, the message, the date and so on."),(0,i.kt)("p",null,"If you want to see a more compact log you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"--oneline")," (",(0,i.kt)("em",{parentName:"p"},"show one line per commit"),") flag:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git log --oneline\n138b404 (HEAD) Merge branch 'more_aliases'\na95bd90 add the 'gm' alias for 'git merge'\na51ae1a (more_aliases) add a file to store 'zsh' aliases\n63ea74f add a file to store 'bash' aliases\nb9ae0ad (aliases) add alias 'gcm' for 'git checkout main'\nf61369d add alias 'gs' for 'git status'\nd7e1bb9 add the 'shell.d' folder\n01e7a10 add the 'install' and 'shell' scripts\n")),(0,i.kt)("p",null,"When you run this command yourself it will be a little easier to read as the output uses different colours for the SHAs and the branch names."),(0,i.kt)("p",null,"We can even see a 'graph' view, showing the branches we have made and when they branched off and were merged back. To do this, pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"--graph")," (",(0,i.kt)("em",{parentName:"p"},"show commit graph"),") flag:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git log --oneline --graph\n*   138b404 (HEAD) Merge branch 'more_aliases'\n| \\\n| * a51ae1a (more_aliases) add a file to store 'zsh' aliases\n| * 63ea74f add a file to store 'bash' aliases\n* | a95bd90 add the 'gm' alias for 'git merge'\n|/\n* b9ae0ad (aliases) add alias 'gcm' for 'git checkout main'\n* f61369d add alias 'gs' for 'git status'\n* d7e1bb9 add the 'shell.d' folder\n* 01e7a10 add the 'install' and 'shell' scripts\n")),(0,i.kt)("p",null,"Each commit is shown with an ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," asterisk symbol - we can also see when we created the ",(0,i.kt)("em",{parentName:"p"},"more_aliases")," branch and when we merged it back in."),(0,i.kt)("p",null,"The Git log is very useful to help you understand the changes that have happened in the repository."),(0,i.kt)("h3",{id:"merge-conflicts"},"Merge Conflicts"),(0,i.kt)("p",null,"One of the most important features of any version control system is the ability to manage ",(0,i.kt)("em",{parentName:"p"},"conflicts"),". Conflicts occur when a set of changes are made that cannot be merged without some kind of manual intervention to decide ",(0,i.kt)("em",{parentName:"p"},"which")," of the changes are correct."),(0,i.kt)("p",null,"Here are a few common scenarios that might lead to merge conflicts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In one branch a file is deleted and in another branch the file is changed - when we merge should we delete the file or keep the version with the changes?"),(0,i.kt)("li",{parentName:"ul"},"In one branch a file is edited and in another branch the ",(0,i.kt)("em",{parentName:"li"},"same")," part of the file is edited in a different way - which edit should we keep? Should we keep both?"),(0,i.kt)("li",{parentName:"ul"},"In one branch we add content to the end of a file and in another branch we add different content - which of these changes should come first?")),(0,i.kt)("p",null,"A lot of the time you can avoid conflicts by making sure that you don't keep branches for too long - if other people are merging changes into the ",(0,i.kt)("em",{parentName:"p"},"main")," branch while you are working on another branch, you are ",(0,i.kt)("em",{parentName:"p"},"drifting")," from the main branch. You should either regularly update your branch with the changes in ",(0,i.kt)("em",{parentName:"p"},"main")," or merge your changes into ",(0,i.kt)("em",{parentName:"p"},"main"),"."),(0,i.kt)("p",null,"There are many different ways for version control systems to manage conflicts. Let's see how Git does it by creating a conflict."),(0,i.kt)("p",null,"First, we will create a branch that adds a new alias to the ",(0,i.kt)("em",{parentName:"p"},"git_aliases.sh")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Create a 'glog_alias' branch and commit a file.\ngit checkout -b glog_alias\necho 'alias glog=\"git log --graph --oneline\"' >> ./shell.d/git_aliases.sh\ngit commit -a -m \"add the 'glog' alias\"\n")),(0,i.kt)("p",null,"Now we'll go back to the ",(0,i.kt)("em",{parentName:"p"},"main")," branch and add another alias:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Go back to 'main' and commit a change to the same file as the last one.\ngit checkout main\necho 'alias glog=\"git log\"' >> ./shell.d/git_aliases.sh\ngit commit -a -m \"add the 'glog' alias\"\n")),(0,i.kt)("p",null,"We've changed the same file in two branches - if we try to merge we will get a conflict:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git merge glog_alias\n\nAuto-merging shell.d/git_aliases.sh\nCONFLICT (content): Merge conflict in shell.d/git_aliases.sh\nAutomatic merge failed; fix conflicts and then commit the result.\n")),(0,i.kt)("p",null,"When Git cannot automatically consolidate the changes into a single merge commit, it aborts the merge process. No new commits have been made - the conflicted files with their changes are in the ",(0,i.kt)("em",{parentName:"p"},"index"),". We have to now manually fix these files."),(0,i.kt)("p",null,"Let's see what the status shows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git status\nOn branch main\nYou have unmerged paths.\n  (fix conflicts and run "git commit")\n  (use "git merge --abort" to abort the merge)\n\nUnmerged paths:\n  (use "git add <file>..." to mark resolution)\n        both modified:   shell.d/git_aliases.sh\n\nno changes added to commit (use "git add" and/or "git commit -a")\n')),(0,i.kt)("p",null,"Git is telling us that we are currently in the process of trying to fix a merge conflict. It is telling us that we need to fix the ",(0,i.kt)("em",{parentName:"p"},"shell.d/git_aliases.sh")," file, then use ",(0,i.kt)("inlineCode",{parentName:"p"},"git add")," to stage the changes and commit the result."),(0,i.kt)("p",null,"To resolve the conflict, we need to edit the file. If you open the file in an editor it will look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'alias gs="git status"\nalias gcm="git checkout main"\nalias gm="git merge"\n<<<<<<< HEAD\nalias glog="git log"\n=======\nalias glog="git log --graph --oneline"\n>>>>>>> glog_alias\n')),(0,i.kt)("p",null,"Many modern editors will immediately recognise the sequence of symbols that Git uses to indicate conflicts and highlight them. The ",(0,i.kt)("inlineCode",{parentName:"p"},"<<<<<< HEAD")," line indicates the changes in the current branch, the ",(0,i.kt)("inlineCode",{parentName:"p"},"=======")," line is a separator, and the ",(0,i.kt)("inlineCode",{parentName:"p"},">>>>>> glog_alias")," line indicates that everything since the ",(0,i.kt)("inlineCode",{parentName:"p"},"=======")," line is the changes in the ",(0,i.kt)("em",{parentName:"p"},"glog_alias")," branch."),(0,i.kt)("p",null,"We can see why Git has not been able to merge these changes - each branch has a new line and Git doesn't know which one is correct. So rather than make an assumption (such as the most recent change should 'win'), Git is asking us to choose."),(0,i.kt)("p",null,"In your editor, update the file to look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'alias gs="git status"\nalias gcm="git checkout main"\nalias gm="git merge"\nalias glog="git log --graph --oneline"\n')),(0,i.kt)("p",null,"We have chosen the version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"glog")," alias that was in the ",(0,i.kt)("em",{parentName:"p"},"glog_alias")," branch. But you could choose either - or replace the content with a new line. You can make any changes you like - just be sure to remove the lines that start with ",(0,i.kt)("inlineCode",{parentName:"p"},"<<<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"===")," and ",(0,i.kt)("inlineCode",{parentName:"p"},">>>"),". We don't even have to use the changes from one of the branches - we could remove the lines or add completely new ones. We change the file to make sure that the merged result makes sense."),(0,i.kt)("p",null,"In the example above we deleted one of the ",(0,i.kt)("inlineCode",{parentName:"p"},"glog")," aliases, but we could have also just changed the name of one of them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'alias gs="git status"\nalias gcm="git checkout main"\nalias gm="git merge"\nalias glog="git log"\nalias ggraph="git log --graph --oneline"\n')),(0,i.kt)("p",null,"We can now use ",(0,i.kt)("inlineCode",{parentName:"p"},"git add")," to mark the file as resolved, and run ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git add shell.d/git_aliases.sh\n")),(0,i.kt)("p",null,"The editor will open showing a sensible commit message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Merge branch 'glog_alias'\n\n# Conflicts:\n#       shell.d/git_aliases.sh\n#\n# It looks like you may be committing a merge.\n# If this is not correct, please run\n#       git update-ref -d MERGE_HEAD\n# and try again.\n\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch main\n")),(0,i.kt)("p",null,"The message is just like the earlier merge commit message, but the comments show a little more information (the files that were conflicted). Save the file and close the editor to complete the commit."),(0,i.kt)("p",null,"Our Git log will now show this new merge commit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git log --graph --oneline\n*   2532277 (HEAD -> main) Merge branch 'glog_alias'\n|\\\n| * a8cbb15 (glog_alias) add the 'glog' alias\n* | 31548e4 add the 'glog' alias\n|/\n*   138b404 Merge branch 'more_aliases'\n|\\\n| * a51ae1a (more_aliases) add a file to store 'zsh' aliases\n| * 63ea74f add a file to store 'bash' aliases\n* | a95bd90 add the 'gm' alias for 'git merge'\n|/\n* b9ae0ad (aliases) add alias 'gcm' for 'git checkout main'\n* f61369d add alias 'gs' for 'git status'\n* d7e1bb9 add the 'shell.d' folder\n* 01e7a10 add the 'install' and 'shell' scripts\n")),(0,i.kt)("p",null,"Dealing with conflicts can be extremely complicated. We have only scratched the surface here, but there is a wealth of information online if you'd like to go deeper."),(0,i.kt)("h3",{id:"other-merge-strategies"},"Other Merge Strategies"),(0,i.kt)("p",null,"Git has a number of merge strategies that can be used to combine the changes across branches. Going into them is beyond the scope of this book. However, it is useful to know that you have a lot of functionality to control how branches are merged available to you if you want to explore further."),(0,i.kt)("p",null,"There are merge strategies that allow you to try and create a single, coherent history between two branches, rather than creating a merge commit, there are options to 'squash' all of the commits from one branch into another and more."),(0,i.kt)("p",null,'I would suggest that as you become more familiar with the basics of how Git works, you get a little deeper on this topic - searching online for "Git Merge Strategies" will bring up many articles going into detail.'),(0,i.kt)("h2",{id:"deleting-and-renaming-files"},"Deleting and Renaming Files"),(0,i.kt)("p",null,"It is quite simple to remove files from your Git Repository. You can either ask Git to remove the file for you, or just delete the file yourself and then tell Git that you have removed it."),(0,i.kt)("p",null,"Let's see both ways in action. First we'll use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git rm")," (",(0,i.kt)("em",{parentName:"p"},"remove files from the working tree and index"),") command",":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git rm install.sh\nrm 'install.sh'\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"git rm")," command removes the file from your working tree and stages the deletion. We can see that the file is staged for deletion if we run ",(0,i.kt)("inlineCode",{parentName:"p"},"git status"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git status\nOn branch main\nChanges to be committed:\n  (use "git restore --staged <file>..." to unstage)\n        deleted:    install.sh\n')),(0,i.kt)("p",null,"The deletion is only in the ",(0,i.kt)("em",{parentName:"p"},"index")," at this stage - we need to run ",(0,i.kt)("inlineCode",{parentName:"p"},"git commit")," to commit the deletion."),(0,i.kt)("p",null,"If we want to restore the file, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," to get the file back from Git:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout HEAD install.sh\n")),(0,i.kt)("p",null,"We use ",(0,i.kt)("inlineCode",{parentName:"p"},"HEAD")," to tell Git what commit we want to checkout the file from - head means the current commit we are on (which is the most recent commit on ",(0,i.kt)("em",{parentName:"p"},"main"),")."),(0,i.kt)("p",null,"Another common way to delete a file is to simply remove it from the file-system:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ rm install.sh\n$ git status\nOn branch main\nChanges not staged for commit:\n  (use "git add/rm <file>..." to update what will be committed)\n  (use "git restore <file>..." to discard changes in working directory)\n        deleted:    install.sh\n')),(0,i.kt)("p",null,"At this point Git knows the file is missing, but the deletion is not yet ",(0,i.kt)("em",{parentName:"p"},"staged")," - because we haven't explicitly told Git that we want to remove this file as part of the commit we are creating. To confirm that we want to remove the file we can use:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git rm install.sh\n")),(0,i.kt)("p",null,"We could also run ",(0,i.kt)("inlineCode",{parentName:"p"},"git add install.sh")," - think of this like saying 'stage my change to ",(0,i.kt)("em",{parentName:"p"},"index.sh"),"' - we are ",(0,i.kt)("em",{parentName:"p"},"adding")," a change to the ",(0,i.kt)("em",{parentName:"p"},"index"),". I often just run ",(0,i.kt)("inlineCode",{parentName:"p"},"git add .")," to add all of my changes (including deletions) to the stage. At this point we can make any other changes we like, stage them, and then commit."),(0,i.kt)("p",null,"Let's restore the file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git reset .\nUnstaged changes after reset:\nD       install.sh\n$ git checkout .\nUpdated 1 path from the index\n")),(0,i.kt)("p",null,"This is another way to restore the file - first we reset all of the changes to the index with ",(0,i.kt)("inlineCode",{parentName:"p"},"git reset ."),", then we checkout all of the files in the current commit with ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout ."),". But be careful with this method - it will also reset any other changes you have made. I prefer the ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout HEAD <file_path>")," method as it is more explicit and only restores one file."),(0,i.kt)("p",null,"What about if we rename a file? Let's rename the install file and see what the status is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ mv install.sh install_dotfiles.sh\nChanges not staged for commit:\n  (use "git add/rm <file>..." to update what will be committed)\n  (use "git restore <file>..." to discard changes in working directory)\n        deleted:    install.sh\n\nUntracked files:\n  (use "git add <file>..." to include in what will be committed)\n        install_dotfiles.sh\n\nno changes added to commit (use "git add" and/or "git commit -a")\n')),(0,i.kt)("p",null,"We've renamed the file, but when we run ",(0,i.kt)("inlineCode",{parentName:"p"},"git status")," it is telling us that the file is missing, and there is a new untracked file. But Git is smart enough to know when we move a file - if we run ",(0,i.kt)("inlineCode",{parentName:"p"},"git add .")," to add all changes in the working tree to the index, Git will recognise that we have not deleted and added a file, but instead renamed it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git add .\n$ git status\nOn branch main\nChanges to be committed:\n  (use "git restore --staged <file>..." to unstage)\n        renamed:    install.sh -> install_dotfiles.sh\n')),(0,i.kt)("p",null,"Let's restore the file by renaming it back to what it was and adding these changes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ mv install_dotfiles.sh install.sh\n$ git add .\n$ git status\nOn branch main\nnothing to commit, working tree clean\n")),(0,i.kt)("p",null,"We can also use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git mv")," (",(0,i.kt)("em",{parentName:"p"},"move or rename a file"),") command"," to move or rename a file and stage the changes in one go:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$ git mv install.sh install_dotfiles.sh\nChanges to be committed:\n  (use "git restore --staged <file>..." to unstage)\n        renamed:    install.sh -> install_dotfiles.sh\n')),(0,i.kt)("p",null,"We can also restore the changes by using ",(0,i.kt)("inlineCode",{parentName:"p"},"git mv"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git mv install_dotfiles.sh install.sh\n$ git status\nOn branch main\nnothing to commit, working tree clean\n")),(0,i.kt)("p",null,"These commands work equally well with folders, or lists of files and folders."),(0,i.kt)("h2",{id:"restoring-your-working-tree"},"Restoring Your Working Tree"),(0,i.kt)("p",null,"We've already seen how the ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," command can be used to switch branches. We can also use the ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout")," command to restore our working tree to a certain point in our commit history. This is extremely useful if you want to see how your files looked at an earlier point in time, or restore your files to a previous state."),(0,i.kt)("p",null,"Let's take a quick look at our Git log so far."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git log --graph --oneline\n*   2532277 (HEAD -> main) Merge branch 'glog_alias'\n|\\\n| * a8cbb15 (glog_alias) add the 'glog' alias\n* | 31548e4 add the 'glog' alias\n|/\n*   138b404 Merge branch 'more_aliases'\n|\\\n| * a51ae1a (more_aliases) add a file to store 'zsh' aliases\n| * 63ea74f add a file to store 'bash' aliases\n* | a95bd90 add the 'gm' alias for 'git merge'\n|/\n* b9ae0ad (aliases) add alias 'gcm' for 'git checkout main'\n* f61369d add alias 'gs' for 'git status'\n* d7e1bb9 add the 'shell.d' folder\n* 01e7a10 add the 'install' and 'shell' scripts\n")),(0,i.kt)("p",null,"The Git log is showing the first seven digits of the SHA for each commit. We can checkout any commit by providing its SHA. We don't need to provide the entire SHA (which is good, because they are normally quite long), we only need to provide enough letters to uniquely identify the commit, so normally four or five digits is plenty."),(0,i.kt)("p",null,"Notice that the most recent commit is marked with the text ",(0,i.kt)("inlineCode",{parentName:"p"},"HEAD"),". The ",(0,i.kt)("em",{parentName:"p"},"HEAD")," is where Git is currently 'pointing' to - we will see how to move the head shortly (the term ",(0,i.kt)("em",{parentName:"p"},"HEAD")," also refers to the most recent commit of a branch)."),(0,i.kt)("p",null,"At the moment we can visualise our Git log, with the commits, branches and HEAD like so:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing our Git log with HEAD indicated",src:a(5524).Z,width:"2992",height:"854"})),(0,i.kt)("p",null,"We can restore the working tree to the state of any of the commits by running ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout <commit_sha>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout f61369d\nNote: switching to 'f61369d'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n")),(0,i.kt)("p",null,"This snippet moved our HEAD to the third commit in our repository. If you look at the files in your working tree you'll see that they are in exact state that they were when we made our third commit. Visually, we have moved the HEAD as shown below:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing a detached HEAD",src:a(7107).Z,width:"2486",height:"742"})),(0,i.kt)("p",null,"The warning that says we are in a 'detached HEAD' state is telling us that our current position in the history is not at the 'tip' of a branch - this means we cannot create a new commit without first starting a new branch."),(0,i.kt)("p",null,"If we want to move back to the 'tip' of our main branch (or any other branch), we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout <branch_name>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout main\n")),(0,i.kt)("p",null,"This moves us back to the 'tip' of the main branch."),(0,i.kt)("p",null,"Git has a very convenient syntax we can use to move backwards. We can specify a branch name, a SHA or 'HEAD', use a ",(0,i.kt)("inlineCode",{parentName:"p"},"~")," tilde character, and then provide the number of commits we want to move 'backwards':"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ git checkout HEAD~1\n")),(0,i.kt)("p",null,"This command moves the 'head' backwards one commit. This is useful if you realise you have made a mistake with your commit or recent commits and want to go backwards."),(0,i.kt)("p",null,"Remember - whenever you run ",(0,i.kt)("inlineCode",{parentName:"p"},"git checkout <branch_name>")," Git moves the HEAD to the tip of the branch by default."),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"In this chapter we looked at some of the core concepts behind Git - the repository, the working tree and the index. We saw how to stage and unstage changes, commit changes, create branches, merge branches, deal with conflicts and remove and rename files."),(0,i.kt)("p",null,"In the next chapter we will look at how to work with 'remote' repositories - this will allow us to push our changes up to a location on the internet and share these changes with other users, or to download these changes to other machines we might work on."),(0,i.kt)("p",null,"We've introduced a lot of commands in this chapter - you can use this table as a quick reference:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Command"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git init")),(0,i.kt)("td",{parentName:"tr",align:null},"Initialise a new Git Repository.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git status")),(0,i.kt)("td",{parentName:"tr",align:null},"Show the status of the working tree and index.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git add <files>")),(0,i.kt)("td",{parentName:"tr",align:null},"Stage ",(0,i.kt)("inlineCode",{parentName:"td"},"files")," - you can use patterns and wildcards.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git reset <files>")),(0,i.kt)("td",{parentName:"tr",align:null},"Unstage ",(0,i.kt)("inlineCode",{parentName:"td"},"files")," - you can use patterns and wildcards.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git rm --cached <files>")),(0,i.kt)("td",{parentName:"tr",align:null},"Unstage ",(0,i.kt)("inlineCode",{parentName:"td"},"files")," - you can use patterns and wildcards.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git commit")),(0,i.kt)("td",{parentName:"tr",align:null},"Create a commit from the current index - the shell editor will open for the commit message.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git commit -m 'message'")),(0,i.kt)("td",{parentName:"tr",align:null},"Create a commit with message ",(0,i.kt)("inlineCode",{parentName:"td"},"message"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git commit -a")),(0,i.kt)("td",{parentName:"tr",align:null},"Stage and commit all changes in the working tree.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git checkout <branch>")),(0,i.kt)("td",{parentName:"tr",align:null},"Checkout a branch called ",(0,i.kt)("inlineCode",{parentName:"td"},"branch"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git checkout -b branch")),(0,i.kt)("td",{parentName:"tr",align:null},"Create and checkout a new branch called ",(0,i.kt)("inlineCode",{parentName:"td"},"branch"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git branch <name>")),(0,i.kt)("td",{parentName:"tr",align:null},"Create a branch called ",(0,i.kt)("inlineCode",{parentName:"td"},"name")," but do not check it out.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git branch -m <new_name>")),(0,i.kt)("td",{parentName:"tr",align:null},"Change the current branch name to ",(0,i.kt)("inlineCode",{parentName:"td"},"new_name"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git merge <branch>")),(0,i.kt)("td",{parentName:"tr",align:null},"Merge the branch named ",(0,i.kt)("inlineCode",{parentName:"td"},"branch")," into the current branch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git log")),(0,i.kt)("td",{parentName:"tr",align:null},"Show the log of commits.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git log --oneline --branch")),(0,i.kt)("td",{parentName:"tr",align:null},"Show the log of commits, one line per commit, with the branch graph.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git rm <files>")),(0,i.kt)("td",{parentName:"tr",align:null},"Stage the removal of ",(0,i.kt)("inlineCode",{parentName:"td"},"files")," from the repostiry - you can use patterns and wildcards.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git mv <source> <destination>")),(0,i.kt)("td",{parentName:"tr",align:null},"Stage the movement of ",(0,i.kt)("inlineCode",{parentName:"td"},"source")," to ",(0,i.kt)("inlineCode",{parentName:"td"},"destination"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git checkout 8342bec")),(0,i.kt)("td",{parentName:"tr",align:null},"Checkout a commit with SHA ",(0,i.kt)("inlineCode",{parentName:"td"},"834bec"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git checkout HEAD~1")),(0,i.kt)("td",{parentName:"tr",align:null},"Move the current HEAD back one commit.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"git checkout <branch>~3")),(0,i.kt)("td",{parentName:"tr",align:null},"Checkout ",(0,i.kt)("inlineCode",{parentName:"td"},"branch"),", move back three commits from the tip.")))))}d.isMDXComponent=!0},9126:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-add-273352897de39c41175ab1570deba674.png"},7685:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-checkout-b-6475f62943d9c57369f6e44991d92efe.png"},7107:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-checkout-detached-head-1a94781840cf8e5c7a4fb3fd4b59ce1b.png"},8853:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-commit-number-2-9dba4c3b9c31e2268ea9ecbbfb1ed196.png"},7745:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-commit-on-aliases-84e8cf5ab03a662ab391896ba9438b7f.png"},9395:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-commit-910cd46c3ad343660e47a0b60cd70934.png"},3763:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-diverged-branches-d7921427ff846f43f168d004001862fb.png"},5524:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-log-showing-head-5a0e2000cb1a17a77297bbb98dd64a12.png"},4983:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-merge-fast-forwards-9cea41f3cdc7252424a0d46eb8aae96e.png"},8506:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-merge-prepare-fast-forwards-62b89b1712bd04787afe47b3c955bc96.png"},4876:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-merge-recursive-e40ed73171c316ca6754a895d84beb07.png"},7878:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/git-reset-ff25fe1fd1489ef9f82cf1b0cc5e7e73.png"}}]);