"use strict";(self.webpackChunkeffective_shell=self.webpackChunkeffective_shell||[]).push([[5615],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>c});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var r=o.createContext({}),p=function(e){var t=o.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},h=function(e){var t=p(e.components);return o.createElement(r.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,c=d["".concat(r,".").concat(u)]||d[u]||m[u]||i;return n?o.createElement(c,l(l({ref:t},h),{},{components:n})):o.createElement(c,l({ref:t},h))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=u;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s[d]="string"==typeof e?e:a,l[1]=s;for(var p=2;p<i;p++)l[p]=n[p];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2608:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const i={title:"Loops and working with Files and Folders",slug:"/part-4-shell-scripting/loops-and-working-with-files-and-folders"},l=void 0,s={unversionedId:"shell-scripting/loops-and-working-with-files-and-folders/index",id:"shell-scripting/loops-and-working-with-files-and-folders/index",title:"Loops and working with Files and Folders",description:"Loops allow us to perform a set of operations over multiple items, such as a set of files or folders or the results of a command. In this chapter we'll look at loops and how to operate on many files and folders.",source:"@site/docs/04-shell-scripting/21-loops-and-working-with-files-and-folders/index.md",sourceDirName:"04-shell-scripting/21-loops-and-working-with-files-and-folders",slug:"/part-4-shell-scripting/loops-and-working-with-files-and-folders",permalink:"/part-4-shell-scripting/loops-and-working-with-files-and-folders",draft:!1,editUrl:"https://github.com/dwmkerr/effective-shell/edit/main/docs/04-shell-scripting/21-loops-and-working-with-files-and-folders/index.md",tags:[],version:"current",frontMatter:{title:"Loops and working with Files and Folders",slug:"/part-4-shell-scripting/loops-and-working-with-files-and-folders"},sidebar:"sidebar",previous:{title:"Mastering Conditional Logic",permalink:"/part-4-shell-scripting/mastering-conditional-logic"},next:{title:"Functions, Parameters and Error Handling",permalink:"/part-4-shell-scripting/functions-parameters-and-error-handling"}},r={},p=[{value:"The For Loop index ",id:"the-for-loop-index-",level:2},{value:"For Loops - Arrays",id:"for-loops---arrays",level:3},{value:"For Loops - Words",id:"for-loops---words",level:3},{value:"For Loops - Files with Wildcards",id:"for-loops---files-with-wildcards",level:3},{value:"For Loops - Files with Find",id:"for-loops---files-with-find",level:3},{value:"For Loops - C Style Loops",id:"for-loops---c-style-loops",level:3},{value:"For Loops - Looping over Sequences",id:"for-loops---looping-over-sequences",level:3},{value:"The While Loop",id:"the-while-loop",level:2},{value:"While Loops - Looping through the lines in a file",id:"while-loops---looping-through-the-lines-in-a-file",level:3},{value:"While Loops - The Infinite Loop",id:"while-loops---the-infinite-loop",level:3},{value:"The Until Loop",id:"the-until-loop",level:2},{value:"Continue and Break",id:"continue-and-break",level:2},{value:"Creating Compact Loops",id:"creating-compact-loops",level:2},{value:"Word Splitting and IFSindex",id:"word-splitting-and-ifsindex",level:2},{value:"Word Splitting",id:"word-splitting",level:3},{value:"The IFS Variable",id:"the-ifs-variable",level:3},{value:"Updating the &#39;common&#39; Command",id:"updating-the-common-command",level:2},{value:"Summary",id:"summary",level:2},{value:"Appendix - Loops and the Z-Shell",id:"appendix---loops-and-the-z-shell",level:3}],h={toc:p};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Loops allow us to perform a set of operations over multiple items, such as a set of files or folders or the results of a command. In this chapter we'll look at loops and how to operate on many files and folders."),(0,a.kt)("h2",{id:"the-for-loop-index-"},"The For Loop"),(0,a.kt)("p",null,"We can use the ",(0,a.kt)("em",{parentName:"p"},"for loop")," to run a set of commands for each item in a list."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"for loop")," has the following structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"for <name> in <words>\ndo\n    <conditional-command 1>\n    <conditional-command 2>\n    <conditional-command n>\ndone\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"for loop")," executes a sequence of commands for every item in a list. In the documentation you will see that this list is called 'words'. There's a technical (and complex) reason for this that we'll discuss in the end of the chapter."),(0,a.kt)("p",null,"Let's see how the ",(0,a.kt)("em",{parentName:"p"},"for loop")," works by showing a simple example. We will loop through every item in a folder and print its name to the screen:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for item in ~/effective-shell/*\ndo\n    echo "Found: $item"\ndone\n')),(0,a.kt)("p",null,"As long as you have the ",(0,a.kt)("em",{parentName:"p"},"effective-shell")," folder in your home directory, you will see output that looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Found: /home/dwmkerr/effective-shell/data\nFound: /home/dwmkerr/effective-shell/docs\nFound: /home/dwmkerr/effective-shell/logs\nFound: /home/dwmkerr/effective-shell/pictures\nFound: /home/dwmkerr/effective-shell/programs\nFound: /home/dwmkerr/effective-shell/quotes\nFound: /home/dwmkerr/effective-shell/scripts\nFound: /home/dwmkerr/effective-shell/templates\nFound: /home/dwmkerr/effective-shell/text\nFound: /home/dwmkerr/effective-shell/websites\n")),(0,a.kt)("p",null,"Notice how the shell is smart enough to ",(0,a.kt)("em",{parentName:"p"},"expand")," the wildcard expression that we have included in the ",(0,a.kt)("em",{parentName:"p"},"for loop"),". In just the same way we can use wildcards in commands such as ",(0,a.kt)("inlineCode",{parentName:"p"},"ls")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"cp")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"mv"),", we can also use them in for loops - or in fact any statement",(0,a.kt)("sup",{parentName:"p",id:"fnref-1"},(0,a.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"!"),(0,a.kt)("p",null,"You will also see that when we specify the name of the variable to use in the loop (which in this example was ",(0,a.kt)("em",{parentName:"p"},"item"),") we don't need to use a dollar symbol. Remember - when we are ",(0,a.kt)("em",{parentName:"p"},"setting")," a variable, we don't use a dollar symbol, we only use the dollar symbol when we want to get the value of the variable."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"for loop")," is closed with the ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," keyword. Here we can also see an inconsistency with the shell syntax - for the ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement, the statement is closed with ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," backwards (",(0,a.kt)("inlineCode",{parentName:"p"},"fi"),"). But the ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop is closed with ",(0,a.kt)("inlineCode",{parentName:"p"},"done"),". The shell is an old platform and there are some oddities like that that you might not see in more modern programming languages."),(0,a.kt)("h3",{id:"for-loops---arrays"},"For Loops - Arrays"),(0,a.kt)("p",null,"In ",(0,a.kt)("a",{parentName:"p",href:"/part-3-manipulating-text/variables-reading-input-and-mathematics/"},"Chapter 19 - Variables, Reading Input, and Mathematics")," we saw how to create arrays. We can easily loop through the items in an array with a for loop. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'days=("Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday")\nfor day in ${days[@]}\ndo\n    echo -n "$day, "\ndone\necho "happy days!"\n')),(0,a.kt)("p",null,"If we run this script we'll see the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, happy days!\n")),(0,a.kt)("p",null,"It's important to remember that we want to go through every item in the array, so we have to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"${days[@]}")," syntax. This is the syntax for 'all of the members of the array'."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"-n")," (",(0,a.kt)("em",{parentName:"p"},"don't output a trailing newline"),") flag of the ",(0,a.kt)("inlineCode",{parentName:"p"},"echo")," command is used inside the for loop so that we don't write each day on its own line."),(0,a.kt)("h3",{id:"for-loops---words"},"For Loops - Words"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"for loop")," documentation names the input to the loop as 'words'. We can see this by running ",(0,a.kt)("inlineCode",{parentName:"p"},"help for"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ help for\nfor: for NAME [in WORDS ... ] ; do COMMANDS; done\n    Execute commands for each member in a list.\n...\n")),(0,a.kt)("p",null,"The reason that the items are called 'words' is that the shell splits up the input into a set of words and loops though each - this can be a real surprise if you come from a programming background."),(0,a.kt)("p",null,"Let's see what this means with an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'sentence="What can the harvest hope for, if not for the care of the Reaper Man?"\nfor word in $sentence\ndo\n    echo "$word"\ndone\n')),(0,a.kt)("p",null,"The output of this will be:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"What\ncan\nthe\nharvest\nhope\nfor,\nif\nnot\nfor\nthe\ncare\nof\nthe\nreaper\nman?\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Z-Shell")," - if you are using Z-Shell then the sentence will ",(0,a.kt)("em",{parentName:"p"},"not")," be split up into words. There is an appendix at the end of the chapter that describes the differences between Z-Shell and Bash-like shells (which tend to be closer to the Posix standard)."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"for loop")," has split up the sentence variable into a set of words. This might seem illogical, as the shell is making quite a big assumption (that the operator ",(0,a.kt)("em",{parentName:"p"},"wants")," their input split up), but we'll see with a few examples how this is often what is needed."),(0,a.kt)("p",null,"This is not how most programming languages would work, so why does the shell do this?"),(0,a.kt)("p",null,"The reason is that the shell is a ",(0,a.kt)("em",{parentName:"p"},"text based environment")," and the designers have taken this into account. Most of the time when we are running shell commands in a terminal we are running commands that ",(0,a.kt)("em",{parentName:"p"},"simply output text"),". If we want to be able to use the output of these commands in constructs like loops, the shell has to decide how to split the output up."),(0,a.kt)("p",null,"For example, let's see how the ",(0,a.kt)("inlineCode",{parentName:"p"},"ls")," command would write its output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ ls ~/effective-shell\ndata  docs  logs  pictures  programs  quotes  scripts  templates  text  websites\n")),(0,a.kt)("p",null,"The output of the ",(0,a.kt)("inlineCode",{parentName:"p"},"ls")," program is plain text. It is not an array, it is just a set of files separated by spaces. What would we expect the shell to do if we ran the following command?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'files=$(ls ~/effective-shell)\nfor file in $files\ndo\n    echo "Found: $file"\ndone\n')),(0,a.kt)("p",null,"The output is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Found: data\nFound: docs\nFound: logs\nFound: pictures\nFound: programs\nFound: quotes\nFound: scripts\nFound: templates\nFound: text\nFound: websites\n")),(0,a.kt)("p",null,"Here we see why the shell splits up words in a sentence. It is making a best effort with plain text - trying to split plain text up into sensible 'chunks'."),(0,a.kt)("p",null,"When we operate in a shell for day to day work we don't have to use the more specific syntax that would be used in a programming language - the shell has more of an emphasis on terseness of statements and the ability to quickly work with files. It is not designed as a general purpose programming tool, so it makes assumptions like this."),(0,a.kt)("p",null,"We go into detail in word splitting nearer the end of this chapter."),(0,a.kt)("h3",{id:"for-loops---files-with-wildcards"},"For Loops - Files with Wildcards"),(0,a.kt)("p",null,"One of the most common scenarios for using a ",(0,a.kt)("em",{parentName:"p"},"for loop")," is to loop through a set of files or folders."),(0,a.kt)("p",null,"The most simple way to do this is to use a simple wildcard pattern in the ",(0,a.kt)("em",{parentName:"p"},"for loop")," statement, like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for script in ~/effective-shell/scripts/*.sh\ndo\n    echo "Found script: $script"\ndone\n')),(0,a.kt)("p",null,"We will see output that looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Found script: /home/dwmkerr/effective-shell/scripts/common.mac.sh\nFound script: /home/dwmkerr/effective-shell/scripts/common.sh\nFound script: /home/dwmkerr/effective-shell/scripts/common.v1.sh\nFound script: /home/dwmkerr/effective-shell/scripts/common.v2.sh\nFound script: /home/dwmkerr/effective-shell/scripts/common.v3.sh\nFound script: /home/dwmkerr/effective-shell/scripts/show-info.sh\n")),(0,a.kt)("p",null,"We have to be careful with scripts like this - there is a bug."),(0,a.kt)("p",null,"By default, if the shell doesn't find anything with a wildcard pattern ",(0,a.kt)("em",{parentName:"p"},"it does not expand it"),". This is very confusing - so let's see an example."),(0,a.kt)("p",null,"Take a look at the sample below - what would you expect it to show?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for script in ~/bad-shell/scripts/*.sh\ndo\n    echo "Found: $script"\ndone\n')),(0,a.kt)("p",null,"You might think the logical result is that nothing is printed - there is not a ",(0,a.kt)("em",{parentName:"p"},"bad shell")," folder, so the pattern should not find any files. But instead, we see the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Found: ~/bad-shell/scripts/*.sh\n")),(0,a.kt)("p",null,"By default, if a shell 'glob' (a pattern that includes a wildcard) does not match any files, the shell simply leaves the pattern as-is."),(0,a.kt)("p",null,"There are two ways we can deal with this problem. The first way is to enable the 'nullglob' (",(0,a.kt)("em",{parentName:"p"},"return null for unmatched globs"),")"," option:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'shopt -s nullglob\nfor script in ~/bad-shell/scripts/*.sh\ndo\n    echo "Found: $script"\ndone\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"shopt")," (",(0,a.kt)("em",{parentName:"p"},"set and unset shell option"),")"," command is used to configure shell options. We will be looking at shell options in detail in Part 5. The 'nullglob' option changes the shell behaviour so that if a wildcard pattern does not match any results, it is set to null string",(0,a.kt)("sup",{parentName:"p",id:"fnref-2"},(0,a.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"."),(0,a.kt)("p",null,"The second way we can deal with this problem is to just use a ",(0,a.kt)("inlineCode",{parentName:"p"},"test")," command. I think that this is actually far more readable than the ",(0,a.kt)("inlineCode",{parentName:"p"},"shopt")," solution. Here's how it would look:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for script in ~/bad-shell/scripts/*.sh\ndo\n    # If the file / folder doesn\'t exist, skip it.\n    if ! [ -e "$script" ]; then continue; fi\n    echo "Found: $script"\ndone\n')),(0,a.kt)("p",null,"Here we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"-e")," (",(0,a.kt)("em",{parentName:"p"},"exists"),") operator in a ",(0,a.kt)("inlineCode",{parentName:"p"},"test")," command to check whether the file exists. If it does ",(0,a.kt)("em",{parentName:"p"},"not")," exist, we run the ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," statement."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," statement 'skips' the current item in the loop and moves to the next one. We will see it a little more later on."),(0,a.kt)("h3",{id:"for-loops---files-with-find"},"For Loops - Files with Find"),(0,a.kt)("p",null,"If the files that you are trying to loop through are too complex to match with a shell pattern, you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," command to search for files, then loop through the results."),(0,a.kt)("p",null,"If you are not familiar with the ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," command, check ",(0,a.kt)("a",{parentName:"p",href:"/part-2-core-skills/finding-files"},"Chapter 11 - Finding Files"),"."),(0,a.kt)("p",null,"Let's use the ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," command to run a loop that prints every symlink in the user's home directory. But before we run the loop we'll create a symlink with a space - this will cause some interesting output in our script:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Create a symlink to 'effective-shell' that has a space in it...\nln -s ~/effective-shell ~/effective\\ shell\n\n# Find all symlinks and print each one.\nlinks=$(find ~ -type l)\nfor link in $links\ndo\n    echo \"Found Link: $link\"\ndone\n")),(0,a.kt)("p",null,"You will see a few different links shown when you run this script, depending on how your system is set up. But you will also certainly see the results below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"...\nFound Link: /home/dwmkerr/effective-shell/effective\nFound Link: shell\n...\n")),(0,a.kt)("p",null,"This is clearly a problem - the shell has taken the path that has a space - ",(0,a.kt)("em",{parentName:"p"},"/home/dwmkerr/effective-shell/effective shell")," and performed ",(0,a.kt)("em",{parentName:"p"},"word splitting")," and turned it into two separate items."),(0,a.kt)("p",null,"This is a persistent headache for anyone who needs to build shell scripts. There are a large number of ways to solve this problem, and none of them are particularly intuitive. I am going to demonstrate one common solution, which is not perfect but should cover most cases. I'll then suggest a better work-around."),(0,a.kt)("p",null,"The solution that we will use is to temporarily change the values that the shell uses to split text into words. We will set it to ",(0,a.kt)("em",{parentName:"p"},"only")," split on newlines. The ",(0,a.kt)("inlineCode",{parentName:"p"},"find")," command puts each file it finds on its own line. This means we will ",(0,a.kt)("em",{parentName:"p"},"not")," split up files with spaces or other whitespace in the name:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Save the current value of IFS - so we can restore it later. Split on newlines.\nold_ifs=$IFS\nIFS=$'\\n'\n\n# Find all symlinks and print each one.\nlinks=$(find ~ -type l)\nfor link in $links\ndo\n    echo \"Found Link: $link\"\ndone\n\n# Restore the original value of IFS.\nIFS=$old_ifs\n")),(0,a.kt)("p",null,"If you run this command now you will see the correct output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"...\nFound Link: /home/dwmkerr/effective-shell/effective shell\n...\n")),(0,a.kt)("p",null,"This will cover you in most cases. However, this method is not ideal for a number of reasons:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"It is quite verbose - we have to store the current value of ",(0,a.kt)("inlineCode",{parentName:"li"},"$IFS")," and then reset it later"),(0,a.kt)("li",{parentName:"ol"},"It is not quite foolproof - filenames on some systems can have a newline character and this script would fail for those files"),(0,a.kt)("li",{parentName:"ol"},"We have to use the complex looking 'ANSI C Quoting' syntax to set ",(0,a.kt)("inlineCode",{parentName:"li"},"$IFS")," to a newline",(0,a.kt)("sup",{parentName:"li",id:"fnref-3"},(0,a.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))),(0,a.kt)("li",{parentName:"ol"},"If the reader doesn't know what ",(0,a.kt)("inlineCode",{parentName:"li"},"$IFS")," is then the entire script will be difficult to follow")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"$IFS")," variable can be complex to work with and discussed at the end of the chapter."),(0,a.kt)("p",null,"I believe that in this case it is probably best to not use a shell script. There is ",(0,a.kt)("em",{parentName:"p"},"no")," solution that is particularly clean or simple. In this case I think you might be better off using a programming language. Check ",(0,a.kt)("a",{parentName:"p",href:"/part-6-advanced-techniques/how-to-avoid-scripting/"},"Chapter 30 - How to Avoid Scripting")," for more details on this."),(0,a.kt)("h3",{id:"for-loops---c-style-loops"},"For Loops - C Style Loops"),(0,a.kt)("p",null,"If you have used programming languages like C, C++, Python, Java and others, you may well be familiar with the 'C style loop' structure that is shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"for (( expression1 ; expression2 ; expression3 ))\ndo\n    <command 1>\n    <command 2>\n    <command n>\ndone\n")),(0,a.kt)("p",null,"This loop structure uses three arithmetic expressions to run the loop. The first is in 'initialise' expression, this is typically used to setup the initial state of the loop. The second is the 'conditional' expression, this is used to check whether the loop is complete. The third is the 'iterate' expression, this is evaluated after the loop commands are completed."),(0,a.kt)("p",null,"Here's how we can use a C style for loop to iterate through five numbers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for (( i = 1; i <= 5; i++ ))\ndo\n    echo "Loop ${i}"\ndone\n')),(0,a.kt)("p",null,"The output of this script is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Loop 1\nLoop 2\nLoop 3\nLoop 4\nLoop 5\n")),(0,a.kt)("h3",{id:"for-loops---looping-over-sequences"},"For Loops - Looping over Sequences"),(0,a.kt)("p",null,"Another common way to use a for loop is with ",(0,a.kt)("em",{parentName:"p"},"brace expansion"),". Brace expansion we have already seen a number of times so far - we can use it to generate a sequence of values. Here is how we might create three files using brace expansion:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"touch {coffee,tea,milkshake}-menu.txt\n")),(0,a.kt)("p",null,"This will create three files:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ ls -1 *-menu.txt\ncoffee-menu.txt\nmilkshake-menu.txt\ntea-menu.txt\n")),(0,a.kt)("p",null,"Brace expansion can be used in for loops, and brace expansion can be used to create sequences. For example, the loop below could be used as a way to loop through the numbers from one to ten:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for i in {1..10}\ndo\n    echo "Loop ${i}"\ndone\n')),(0,a.kt)("p",null,"Brace expansion can be used to loop through a sequence of values or a range of numbers. You can even specify the 'increment' used in a sequence. For example, this loop iterates through a sequence of numbers adding five each time:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for i in {0..25..5}\ndo\n    echo "Loop ${i}"\ndone\n')),(0,a.kt)("p",null,"The output of this loop would be:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Loop 0\nLoop 5\nLoop 10\nLoop 15\nLoop 20\nLoop 25\n")),(0,a.kt)("h2",{id:"the-while-loop"},"The While Loop"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"while loop")," is a loop that executes commands until a certain condition is met."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"while loop")," has the following structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"while <test-commands>\ndo\n    <conditional-command 1>\n    <conditional-command 2>\n    <conditional-command n>\ndone\n")),(0,a.kt)("p",null,"As long as the ",(0,a.kt)("em",{parentName:"p"},"test commands")," return success, the loop will run the ",(0,a.kt)("em",{parentName:"p"},"conditional commands"),". After the ",(0,a.kt)("em",{parentName:"p"},"conditional commands")," have been run, the loop goes 'back to the start' and evaluates the test commands again."),(0,a.kt)("p",null,"Here's an example of how a while loop can be used to generate a list of random numbers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'# Create an empty array of random numbers.\nrandom_numbers=()\n\n# As long as the length of the array is less than five, continue to loop.\nwhile [ ${#random_numbers[@]} -lt 5 ]\ndo\n    # Get a random number, ask the user if they want to add it to the array.\n    random_number=$RANDOM\n    read -p "Add $random_number to the list? (y/n): " choice\n\n    # If the user chose \'y\' add the random number to the array.\n    if [ "$choice" = "y" ]; then random_numbers+=($random_number); fi\ndone\n\n# Show the contents of the array.\necho "Random Numbers: ${random_numbers[@]}"\n')),(0,a.kt)("p",null,"When you run this script, you can choose to add a number to the list by typing 'y' - once there are five items in the list the while loop condition fails and the loop ends:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Add 14718 to the list? (y/n): y\nAdd 2646 to the list? (y/n): n\nAdd 11898 to the list? (y/n): y\nAdd 31506 to the list? (y/n): y\nAdd 32436 to the list? (y/n): y\nAdd 6803 to the list? (y/n): n\nAdd 25811 to the list? (y/n): y\nRandom Numbers: 14718 11898 31506 32436 25811\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"$RANDOM")," variable is a built-in variable in the shell that returns a random number."),(0,a.kt)("p",null,"You would typically use a while loop when you don't know how many iterations you will perform and you need to re-evaluate at each iteration whether you should continue to loop."),(0,a.kt)("h3",{id:"while-loops---looping-through-the-lines-in-a-file"},"While Loops - Looping through the lines in a file"),(0,a.kt)("p",null,"You can use a while loop to iterate through each line in a file, without having to load the entire file into memory."),(0,a.kt)("p",null,"Here's an example of how to iterate through the lines of a file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'while read line; do\n    echo "Read: $line"\ndone < ~/effective-shell/data/top100.csv\n')),(0,a.kt)("p",null,"The output will look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Read: "Rank","Rating","Title","Reviews"\nRead: "1","97","Black Panther (2018)","515"\nRead: "2","94","Avengers: Endgame (2019)","531"\n...\n')),(0,a.kt)("p",null,"This uses shell redirection to redirect the contents of the ",(0,a.kt)("em",{parentName:"p"},"~/effective-shell/data/top100.csv")," file into the ",(0,a.kt)("inlineCode",{parentName:"p"},"read")," command in the while loop. The ",(0,a.kt)("inlineCode",{parentName:"p"},"read")," command will read the file, line by line, until it finds the final line."),(0,a.kt)("p",null,"This script has some issues:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the last line is does not end with a newline, then it is not read"),(0,a.kt)("li",{parentName:"ul"},"Backlashes will be treated as escape sequences and lead to broken output"),(0,a.kt)("li",{parentName:"ul"},"Leading whitespace will be removed")),(0,a.kt)("p",null,"It is possible to avoid these issues, but the resulting script is a lot harder to read:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'while IFS="" read -r line || [ -n "$line" ]; do\n    echo "Read: $line"\ndone < ~/effective-shell/data/top100.csv\n')),(0,a.kt)("p",null,"In this case we've had to use some complex tricks to avoid each issue:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},'|| [ -n "$line"]')," test ensures that the loop iterates as long as the line read is not zero-length, ensuring we read the last line even if it doesn't have a newline"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"-r")," (",(0,a.kt)("em",{parentName:"li"},"do not escape"),") option for ",(0,a.kt)("inlineCode",{parentName:"li"},"read")," ensures that backlashes are not interpreted as escape sequences"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},'IFS=""')," temporarily disables ",(0,a.kt)("em",{parentName:"li"},"any")," word splitting in the loop, meaning that we do not lose leading whitespace")),(0,a.kt)("p",null,"However this ",(0,a.kt)("em",{parentName:"p"},"still")," has issues - if commands in the loop read from standard input then the loop will still have errors. For this reason, I would again suggest you follow the advice in the ",(0,a.kt)("a",{parentName:"p",href:"../../work-in-progress"},"How to avoid scripting!")," Chapter to see better ways to read files!"),(0,a.kt)("p",null,"Even though I would recommend using a programming language to read the lines of a file, I have kept this example here because it is something you are likely to come across if you see scripts written by others. And for simple scenarios, where you are fairly sure of structure of a file, it might be useful. But this is definitely a case where you should consider using a programming language if you want to create more maintainable solutions to problems!"),(0,a.kt)("h3",{id:"while-loops---the-infinite-loop"},"While Loops - The Infinite Loop"),(0,a.kt)("p",null,"There are times that you may want to loop forever. For example you might be writing a script that reads an option from the user, processes it, and then starts again."),(0,a.kt)("p",null,"Here's an example of an infinite loop - we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," command, which always returns success:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'while true\ndo\n    echo "1) Move forwards"\n    echo "2) Move backwards"\n    echo "3) Turn Left"\n    echo "4) Turn Right"\n    echo "5) Explore"\n    echo "0) Quit"\n\n    read -p "What will you do: " choice\n    if [ $choice -eq 0 ]; then\n        exit\n    fi\n    # The rest of the game logic would go here!\n    # ...\ndone\n')),(0,a.kt)("p",null,"This example shows a common pattern for an infinite loop - offering a menu of options which the user can call repeatedly until they decide to quit."),(0,a.kt)("h2",{id:"the-until-loop"},"The Until Loop"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"until loop")," operates just like the while loop, except that it runs ",(0,a.kt)("em",{parentName:"p"},"until")," the test commands return success."),(0,a.kt)("p",null,"The structure of the ",(0,a.kt)("em",{parentName:"p"},"until loop")," is just like the while loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"until <test-commands>\ndo\n    <conditional-command 1>\n    <conditional-command 2>\n    <conditional-command n>\ndone\n")),(0,a.kt)("p",null,"As long as the ",(0,a.kt)("em",{parentName:"p"},"test commands")," do not return success, the loop will run the ",(0,a.kt)("em",{parentName:"p"},"conditional commands"),". After the ",(0,a.kt)("em",{parentName:"p"},"conditional commands")," have been run, the loop goes 'back to the start' and evaluates the test commands again."),(0,a.kt)("p",null,"Here's an example of an ",(0,a.kt)("em",{parentName:"p"},"until")," loop that builds a random number that is at least 15 characters long:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'# Create an empty random number string - we\'re going to build it up in the loop.\nrandom_number=""\n\n# Keep on looping until the random number is at least 15 characters long.\nuntil [ "${#random_number}" -ge 15 ]\ndo\n    random_number+=$RANDOM\ndone\necho "Random Number: ${random_number}"\n')),(0,a.kt)("p",null,"When you run this script you will see something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Random Number: 364272371462227929\n")),(0,a.kt)("p",null,"Note that we've used the string-length parameter expansion function to get the length of the ",(0,a.kt)("inlineCode",{parentName:"p"},"random_number_")," variable here. If this is not familiar, check ",(0,a.kt)("a",{parentName:"p",href:"/part-3-manipulating-text/variables-reading-input-and-mathematics/"},"Chapter 19 - Variables, Reading Input, and Mathematics"),"."),(0,a.kt)("p",null,"In general I would recommend using while loops rather than until loops. While loops are going to be more familiar to readers as they exist in many programming languages - until loops are a little more rare. And you can easily turn any until loop into a while loop by simply inverting the test commands you are running."),(0,a.kt)("p",null,"For example, we could re-write the loop created before like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'random_number=""\nwhile [ "${#random_number}" -lt 15 ]\ndo\n    random_number+=$RANDOM\ndone\necho "Random Number: ${random_number}"\n')),(0,a.kt)("p",null,"In this case we've changed the condition from ",(0,a.kt)("inlineCode",{parentName:"p"},"-ge 15")," (greater than or equal to fifteen) to ",(0,a.kt)("inlineCode",{parentName:"p"},"-lt 15")," (less than fifteen). The while loop version of the script will probably be a little easier for most readers to parse."),(0,a.kt)("h2",{id:"continue-and-break"},"Continue and Break"),(0,a.kt)("p",null,"We briefly saw that the ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," (",(0,a.kt)("em",{parentName:"p"},"resume loop"),") statement"," can be used to 'skip' an iteration in a loop. ",(0,a.kt)("inlineCode",{parentName:"p"},"break")," (",(0,a.kt)("em",{parentName:"p"},"exit loop"),") statement that can be used to stop running the loop."),(0,a.kt)("p",null,"When we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," statement, we are telling the shell that we want to ",(0,a.kt)("em",{parentName:"p"},"stop")," processing the current 'iteration' of the loop and move onto the next item. You can use as many ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," statements as you like in a loop."),(0,a.kt)("p",null,"Here's an example of a script that let's the users show the contents of a directory. If the directory is empty it uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," statement to skip to the next directory. If the users chooses to cancel the operation, it uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"break")," statement to stop iterating:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'echo "For each folder, choose y/n to show contents, or c to cancel."\nfor file in ~/*\ndo\n    # If the file is not a directory, or it cannot be searched, skip it.\n    if ! [ -d "$file" ] || ! [ -x "$file" ]; then continue; fi\n\n    # Ask the user if they want to see the contents.\n    read -p "Show: $file? [y/n/c]: " choice\n\n    # If the user chose \'c\' for cancel, break.\n    if [ "$choice" = "c" ]; then break; fi\n\n    # If the user choice \'y\' to show contents, list them.\n    if [ "$choice" = "y" ]; then ls "$file"; fi\ndone\n')),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," can simplify our loops - otherwise it would be much harder to write the loop above."),(0,a.kt)("h2",{id:"creating-compact-loops"},"Creating Compact Loops"),(0,a.kt)("p",null,"In each example in this chapter we have split the loop constructs so that there is one statement per line. But just as with the ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement, we can combine any of these lines, as long as we use a semi-colon to let the shell know where each statement ends."),(0,a.kt)("p",null,"A common pattern you will see is the ",(0,a.kt)("inlineCode",{parentName:"p"},"do")," keyword on the same line as the ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"while")," statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'numbers=(0 1 1 2 3 5)\nfor num in ${numbers[@]}; do\n    echo "$num"\ndone\n')),(0,a.kt)("p",null,"If you are simply typing in the shell in a terminal, rather than writing a script, you might write the loop on a single line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for script in *.sh; do touch "$script"; done\n')),(0,a.kt)("p",null,"This one-liner updates the last access and modified of all files that end with ",(0,a.kt)("em",{parentName:"p"},"*.sh")," in the current folder."),(0,a.kt)("p",null,"Just like with the ",(0,a.kt)("em",{parentName:"p"},"if statement")," I would recommend that you keep each statement on its own line until you are 100% familiar with the syntax. Then when it is second-nature to be able to write a loop, you can use the more compact syntax if it is appropriate."),(0,a.kt)("p",null,"When you are running the shell ",(0,a.kt)("em",{parentName:"p"},"interactively"),", i.e. actually typing in the shell rather than writing a shell script, you can still use multiple lines. If you type ",(0,a.kt)("inlineCode",{parentName:"p"},"for script in *.sh")," and press enter, the shell will let you type the next line. You can keep on adding lines until you type ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," and press enter."),(0,a.kt)("p",null,"If you want to make a ",(0,a.kt)("em",{parentName:"p"},"really")," compact for loop, you can actually skip the ",(0,a.kt)("inlineCode",{parentName:"p"},"in <words>")," part. If ",(0,a.kt)("inlineCode",{parentName:"p"},"in <words>")," is omitted then the special 'all parameters' variable ",(0,a.kt)("inlineCode",{parentName:"p"},"$@")," is used. We will look at this special parameter in the next chapter. But this will be confusing to readers so I would recommend that you are always explicit with the ",(0,a.kt)("inlineCode",{parentName:"p"},"in <words")," part of a for loop."),(0,a.kt)("h2",{id:"word-splitting-and-ifsindex"},"Word Splitting and IFS"),(0,a.kt)("p",null,"At a number of points in this chapter we have touched on the concept of 'word-splitting'"," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"$IFS")," variable. Before we close out the chapter with an update to the ",(0,a.kt)("inlineCode",{parentName:"p"},"common")," script, let's talk about these concepts in more detail."),(0,a.kt)("p",null,"If you are not expecting to use shell scripts as a regular part of your work you can safely skip this section. If you think that you are likely to come across shell scripts, loops and similar constructs, it might be worth reading this section."),(0,a.kt)("h3",{id:"word-splitting"},"Word Splitting"),(0,a.kt)("p",null,"Word splitting is the process by which the shell splits text up into a set of words."),(0,a.kt)("p",null,"We saw that the shell will split the words in a loop, which we can see with the example below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'$ sentence="Here are some words"\nfor word in $sentence; do echo "$word"; done\nHere\nare\nsome\nwords\n')),(0,a.kt)("p",null,"But why is it that wrapping the ",(0,a.kt)("inlineCode",{parentName:"p"},"$sentence")," variable in quotes stops the word splitting from happening?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'$ sentence="Here are some words"\nfor word in "$sentence"; do echo "$word"; done\nHere are some words\n')),(0,a.kt)("p",null,"The reason for this has been touched on in ",(0,a.kt)("a",{parentName:"p",href:"/part-3-manipulating-text/variables-reading-input-and-mathematics/"},"Chapter 19 - Variables, Reading Input, and Mathematics")," and also partly in this chapter."),(0,a.kt)("p",null,"In the first example the loop iterates over the ",(0,a.kt)("inlineCode",{parentName:"p"},"$sentence")," variable. Note that this variable is ",(0,a.kt)("em",{parentName:"p"},"not")," quoted. This means that it follows the standard rules for 'expansion' in the shell. This means that as well as all of the usual features such as wildcard expansion, ",(0,a.kt)("em",{parentName:"p"},"word expansion")," will occur."),(0,a.kt)("p",null,"In the second example, the loop iterates over the ",(0,a.kt)("inlineCode",{parentName:"p"},'"$sentence"')," variable. Note that this variable ",(0,a.kt)("em",{parentName:"p"},"is")," quoted. As we saw in ",(0,a.kt)("a",{parentName:"p",href:"/part-3-manipulating-text/variables-reading-input-and-mathematics/"},"Chapter 19")," quoting a variable means that it is treated literally, expect for parameter expansion."),(0,a.kt)("p",null,"This means that in most circumstances you probably want to quote your variables - otherwise the shell is going to perform word splitting on them. But if you ",(0,a.kt)("em",{parentName:"p"},"do")," want expansion and splitting to occur, then you should ",(0,a.kt)("em",{parentName:"p"},"not")," quote text. For example, if we run the following we see invalid output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'$ for file in "*"; do echo "Found: $file"; done\nFound: *\n')),(0,a.kt)("p",null,"Because we have quoted the asterisks, the shell does not treat it as a special character which expands into a list of files."),(0,a.kt)("p",null,"What about this example, when we use wildcard expansion to list files, but the results do ",(0,a.kt)("em",{parentName:"p"},"not")," have word splitting applied?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'$ touch file\\ with\\ spaces.test\n$ for file in *.test; do echo "Found: $file"; done\nFound: file with spaces.test\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"*.test")," is not surrounded in quotes, so it is expanded. But why does word splitting not happen?"),(0,a.kt)("p",null,"The reason is that the shell applies these 'expansions' in a certain order, which is as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Brace expansion"),(0,a.kt)("li",{parentName:"ul"},"Tilde expansion"),(0,a.kt)("li",{parentName:"ul"},"Parameter and variable expansion"),(0,a.kt)("li",{parentName:"ul"},"Command substitution"),(0,a.kt)("li",{parentName:"ul"},"Arithmetic expansion"),(0,a.kt)("li",{parentName:"ul"},"Word splitting"),(0,a.kt)("li",{parentName:"ul"},"Pathname expansion")),(0,a.kt)("p",null,"Word splitting happens ",(0,a.kt)("em",{parentName:"p"},"before")," pathname expansion, and it is pathname expansion that turns the asterisks wildcard into the list of files. At the point that this happens, word splitting has already been applied and won't be applied again."),(0,a.kt)("p",null,"Each of these types of expansion we have actually already seen in the book, but we're going to review them in detail in the final section on advanced techniques. You can find the appropriate section of the Bash manual for this topic by searching for ",(0,a.kt)("inlineCode",{parentName:"p"},"EXPANSION"),"."),(0,a.kt)("h3",{id:"the-ifs-variable"},"The IFS Variable"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"$IFS")," variable is the 'internal field separator' variable. It is what the shell uses to decide what characters should be used to split up text into words. By default, this variable includes the space character, the tab character and the newline character."),(0,a.kt)("p",null,"Whenever you see a script or a command that ",(0,a.kt)("em",{parentName:"p"},"changes")," the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"$IFS")," variable, the operator is modifying the behaviour of subsequent commands so that they do not split words in the same way."),(0,a.kt)("p",null,"Here's an example of how we could change the IFS variable to split text using commas:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'text="mother,danzig,1988"\nIFS=","\nfor word in $text\ndo\n    echo "Word: $word"\ndone\n')),(0,a.kt)("p",null,"This script will split text using the comma symbol and output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Word: mother\nWord: danzig\nWord: 1988\n")),(0,a.kt)("p",null,"Be careful when changing the ",(0,a.kt)("inlineCode",{parentName:"p"},"IFS")," variable - it could cause subsequent commands to behave in unexpected ways. You should normally first copy current value into a variable, then change it, then set it back, like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'old_ifs="$IFS"\nIFS=":"\n# Do some stuff\nIFS="$old_ifs"\n')),(0,a.kt)("p",null,"In general if you are changing ",(0,a.kt)("inlineCode",{parentName:"p"},"IFS")," you might be doing something that would be better done with a programming language."),(0,a.kt)("h2",{id:"updating-the-common-command"},"Updating the 'common' Command"),(0,a.kt)("p",null,"In the previous chapter we created the ",(0,a.kt)("inlineCode",{parentName:"p"},"common.v3.sh")," command, that shows common commands from the users shell history."),(0,a.kt)("p",null,"If you need a refresher on what is in the script, you can view it in your pager with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"less ~/effective-shell/scripts/common.v3.sh\n")),(0,a.kt)("p",null,"Let's add a loop to our common to show a number next to each command so that we can see the order of the commands."),(0,a.kt)("p",null,"As the file is a little larger now, I am not going to show the entire file, only the key changes we will make."),(0,a.kt)("p",null,"First, in each of the sections that performs the command to get the common commands we will use Command Substitution to run a sub-shell and store the results in a variable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Store the most recently used commands in the 'commands' variable.\ncommands=$(tail ~/.bash_history -n ${history_lines} \\\n    | sort \\\n    | uniq -c \\\n    | sed 's/^ *//' \\\n    | sort -n -r \\\n    | head -n ${command_count})\n")),(0,a.kt)("p",null,"There are two places we have to make this change - the first is for the Bash Shell and the second is for the Z-Shell. Now that we have stored our commands in a variable, we can loop through it at the end of the script and show a number that gives the order of each command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Print each command, showing what its order is in the list.\n# Commands are separated by newlines, so temporarily change IFS to loop over\n# each line of the commands.\ncounter=1\nold_ifs=$IFS\nIFS=$'\\n'\nfor command in $commands\ndo\n    echo \"$counter: $comand\"\n    counter=$((counter + 1))\ndone\nIFS=$old_ifs\n")),(0,a.kt)("p",null,"The updated script is in the samples folder at ",(0,a.kt)("em",{parentName:"p"},"~/effective-shell/scripts/common.v4.sh"),", you can update your link to point to this version by running the ",(0,a.kt)("inlineCode",{parentName:"p"},"ln")," command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ln -s ~/effective-shell/scripts/common.v4.sh /usr/local/bin/common\n")),(0,a.kt)("p",null,"Now when we run this command, each of our common commands is printed with its order shown:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ common\n1: 135 gst\n2: 73 vi\n3: 47 gc\n4: 40 ls\n5: 37 ga .\n6: 27 gpo\n7: 25 gl\n8: 24 gpr\n9: 21 gcm\n10: 17 make dev\n")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"In this chapter we looked at how to use different types of loops in the shell, to iterate over values in an array, words in a sentence, files and folders or even the results of commands."),(0,a.kt)("p",null,"We also looked in detail at how 'word-splitting' works, as well as the ",(0,a.kt)("inlineCode",{parentName:"p"},"$IFS")," variables. In the next chapter we'll look at functions and parameters."),(0,a.kt)("h3",{id:"appendix---loops-and-the-z-shell"},"Appendix - Loops and the Z-Shell"),(0,a.kt)("p",null,"The Z-Shell does ",(0,a.kt)("em",{parentName:"p"},"not")," perform word-splitting on unquoted variables. This is a deliberate choice by the designers, to avoid what can often be confusing behaviour."),(0,a.kt)("p",null,"We can see this behaviour below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'% sentence="one two three"\n% for word in $sentence; do echo "Word: $word"; done\nWord: one two three\n')),(0,a.kt)("p",null,"If you want to use more Posix-like functionality then you can set the ",(0,a.kt)("inlineCode",{parentName:"p"},"SH_WORD_SPLIT")," parameter. You can find out more about this parameter by running ",(0,a.kt)("inlineCode",{parentName:"p"},"man zsh")," and searching for ",(0,a.kt)("inlineCode",{parentName:"p"},"SH_WORD_SPLIT"),"."),(0,a.kt)("div",{className:"footnotes"},(0,a.kt)("hr",{parentName:"div"}),(0,a.kt)("ol",{parentName:"div"},(0,a.kt)("li",{parentName:"ol",id:"fn-1"},"If we had put quotes around the wildcard text it would ",(0,a.kt)("em",{parentName:"li"},"not")," be expanded - check the section on 'Quoting' in ",(0,a.kt)("a",{parentName:"li",href:"/part-3-manipulating-text/variables-reading-input-and-mathematics/"},"Chapter 19 - Variables, Reading Input, and Mathematics")," if you need a refresher on this.",(0,a.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,a.kt)("li",{parentName:"ol",id:"fn-2"},"There is a good reason for this. Would you prefer ",(0,a.kt)("inlineCode",{parentName:"li"},"ls *.nothing-here")," to show a warning that ",(0,a.kt)("em",{parentName:"li"},"*.nothing-here")," doesn't exist or show the result of ",(0,a.kt)("inlineCode",{parentName:"li"},"ls")," - which lists the current directory! This is discussed in more detail on this Stack Overflow thread: ",(0,a.kt)("a",{parentName:"li",href:"https://unix.stackexchange.com/questions/204803/why-is-nullglob-not-default"},"https://unix.stackexchange.com/questions/204803/why-is-nullglob-not-default"),(0,a.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")),(0,a.kt)("li",{parentName:"ol",id:"fn-3"},"ANSI C Quoting is described in the 'Quoting' section in ",(0,a.kt)("a",{parentName:"li",href:"/part-3-manipulating-text/variables-reading-input-and-mathematics/"},"Chapter 19 - Variables, Reading Input, and Mathematics"),(0,a.kt)("a",{parentName:"li",href:"#fnref-3",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0}}]);