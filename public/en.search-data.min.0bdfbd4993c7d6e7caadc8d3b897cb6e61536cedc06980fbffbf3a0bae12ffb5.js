'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/effective-shell/docs/example/','title':"Example Site",'content':"Introduction Ferre hinnitibus erat accipitrem dixi Troiae tollens Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"});index.add({'id':1,'href':'/effective-shell/docs/example/table-of-contents/with-toc/','title':"With ToC",'content':"Caput vino delphine in tamen vias Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  Natus quaerere Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\n Phrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\n Limitibus misere sit Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"});index.add({'id':2,'href':'/effective-shell/docs/example/table-of-contents/without-toc/','title':"Without ToC",'content':"At me ipso nepotibus nunc celebratior genus Tanto oblite Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"});index.add({'id':3,'href':'/effective-shell/docs/example/table-of-contents/','title':"Table of Contents",'content':"Ubi loqui Mentem genus facietque salire tempus bracchia Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':4,'href':'/effective-shell/docs/example/2nd/','title':"2nd",'content':"2nd Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':5,'href':'/effective-shell/docs/example/2nd/3rd/4th/','title':"4th",'content':"4th Level of Menu Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':6,'href':'/effective-shell/docs/example/2nd/3rd/','title':"3rd",'content':"3rd Level of Menu Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "});index.add({'id':7,'href':'/effective-shell/docs/example/hidden/','title':"Hidden",'content':"This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "});index.add({'id':8,'href':'/effective-shell/docs/section1/1-navigating-the-command-line/','title':"1 Navigating the Command Line",'content':"Navigating the Command Line I can't think of a better place to start than navigating the command line. As you start to do more and more in the shell, text in the command line can quickly become hard to handle. In this article I'll show some simple tricks for working with the command line more effectively.\nHere's a quick reference diagram, the rest of the article goes into the details!\n\nThis article, examples and diagrams are available at github.com/dwmkerr/effective-shell.\n Basic Navigation Searching Editing In-Place Clear the Screen Pro Tip: All The Keys! Pro Tip: Transposing! Closing Thoughts  Basic Navigation Let's assume we have a very simple command we are writing, which is going to write a quote to a text file:\necho \u0026#34;The trouble with writing fiction is that it has to make sense, whereas real life doesn\u0026#39;t. -- Iain M. Banks\u0026#34; \u0026gt;\u0026gt; quote.txt Navigating around long lines of text is a slow process if you are only relying on the arrow keys, so take the time to learn the following shortcuts:\n   Action Shortcut Example     Go to beginning / end Ctrl + a / Ctrl + e    Go backwards / forwards one word Alt + b / Alt + f    Delete a word / undo Ctrl + w / Ctrl + -    Delete next word Alt + d    Delete all the way to the beginning1 Ctrl + u    Delete all the way to the end Ctrl + k     Searching Once you have the basic navigation commands down, the next essential is searching. Let's assume we've run the following three commands:\n$ command1 param1 param2 param3 $ command2 param4 param5 param6 $ command3 param7 param8 param9 You can search backwards or forwards with Ctrl + r and Ctrl + s. This will search in the current command and then iteratively through previous commands:\nThis is useful for searching in the current command, but can be also used to quickly search backwards and forwards through the command history:\nAs you type, your command history is searched, the most recent commands coming first. Use the arrow keys to edit the command, press enter to execute it, or Ctrl + g to cancel the search.\nHere are the same commands applied to the original example:\n   Action Shortcut Example     Search backwards / forwards Ctrl + r / Ctrl + s    Run the command Enter    Edit the command Right Arrow / Left Arrow    Stop searching Ctrl + g     Editing In-Place These tips and tricks are helpful, but if you are working with a really long or complex command, you might find it useful just to jump into your favourite editor.\nUse Ctrl + x , Ctrl + e to edit-in place:\nIn a later article I'll talk a little more about how to configure the default editor.\nClear the Screen Probably the shortcut I use the most is Ctrl + l, which clears the screen without trashing your current command. Here's how it looks:\nPro Tip: All The Keys! You can use the bindkey command to see a list of all keyboard shortcuts:\n$ bindkeys \u0026quot;^@\u0026quot; set-mark-command \u0026quot;^A\u0026quot; beginning-of-line \u0026quot;^B\u0026quot; backward-char \u0026quot;^D\u0026quot; delete-char-or-list \u0026quot;^E\u0026quot; end-of-line \u0026quot;^F\u0026quot; forward-char \u0026quot;^G\u0026quot; send-break \u0026quot;^H\u0026quot; backward-delete-char \u0026quot;^I\u0026quot; expand-or-complete \u0026quot;^J\u0026quot; accept-line \u0026quot;^K\u0026quot; kill-line \u0026quot;^L\u0026quot; clear-screen ... This is an extremely useful command to use if you forget the specific keyboard shortcuts, or just want to see the shortcuts which are available.\nPro Tip: Transposing! If you've mastered all of the commands here and feel like adding something else to your repertoire, try this:\nThe Alt + t shortcut will transpose the last two words. Use Ctrl + t to transpose the last two letters:\nThese were new to me when I was researching for this article. I can't see myself ever being able to remember the commands more quickly than just deleting the last two words or characters and re-typing them, but there you go!\nClosing Thoughts If you are ever looking to go deeper, then search the web for GNU Readline, which is the library used under the hood to handle the command line in many shells. You can actually configure lower level details of how all shells which use readline work, with the .inputrc configuration file.\nThe great thing about learning these shortcuts is that they will work in any prompt which uses GNU Readline. This means everything you've learnt applies to:\n Bash zsh The Python REPL The Node.js REPL  And probably a whole bunch more2.\nAll of these shortcuts should be familar to Emacs users. There is in fact a \u0026lsquo;Vi Mode\u0026rsquo; option for readline, which allows you to use vi commands to work with text. You can enter this mode with set -o vi, I'll likely come back to this in detail in a later article.\nThere's a great cheat sheet on emacs readline commands at readline.kablamo.org/emacs, which is a very useful reference if you want to dig deeper. For this article I've tried to focus on what I think are the most useful commands (and transpose just so you can show off!).\nHope that was useful! GIFs were made with LICEcap.\nFootnotes References  Wikipedia: GNU Readline GNU Org: Readline Init File Kablamo.org: Readline Cheat Sheet    If you are using zsh, then this will clear the entire line. \u0026#x21a9;\u0026#xfe0e;\n If you know of any more, please let me know and I'll update the article! \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':9,'href':'/effective-shell/docs/section1/2-clipboard-gymnastics/','title':"2 Clipboard Gymnastics",'content':"Become a Clipboard Gymnast In this article I'll show you how you can use the shell as an efficient tool to compliment how you use the clipboard.\nNote for Linux Users: In this article I'll use the pbcopy and pbpaste commands to access the clipboard, which are available on a Mac only. To get access to the same commands on other platforms, check Appendix: Clipboard Access on Linux\nUse the Shell on the Clipboard You can easily use shell commands on the contents of your clipboard. Just use pbpaste to output the clipboard, run the output through some commands, then use pbcopy to copy the result.\nTry copying the following text:\nKirk Van Houten Timothy Lovejoy Artie Ziff Then in the shell, run:\npbpaste You should see the contents of the clipboard. Now we'll look at some ways that shell access to the clipboard can help with common tasks.\nRemoving Formatting Don't you hate it when you have to copy formatted text and don't have an easy way to paste it as unformatted text? Here's an example, I want to copy this Wikipedia page on \u0026lsquo;bash\u0026rsquo;, and paste it into a Word document:\nMany programs have a shortcut to paste the contents of the clipboard (such as \u0026lsquo;command + shift + v\u0026rsquo;) but if you are like me you might find yourself pasting into a plain text editor just to copy out the plain text.\nIf you just run the command pbpaste | pbcopy, you can easily strip the formatting:\nWe're just piping out the clipboard (which ends up as plain text, cause we're in a terminal!) and then piping that plain text back into the clipboard, replacing the formatted text which was there before.\nThis little trick can be very useful. But we can use the same pattern to quickly manipulate the contents of the clipboard in more sophisticated ways.\nManipulating Text Let's say someone has emailed me a list of people I need to invite to an event:\nThe problem is:\n The list is in Excel and is formatted The list has duplicates I need to turn each name into an email address like 'Artie_Ziff@simpsons.com\u0026rsquo;  And I want to email everyone quickly.\nWe can quickly handle this task without leaving the shell.\nCopy the raw text below if you want to try out the same commands and follow along:\nArtie Ziff Kirk Van Houten Timothy Lovejoy Artie Ziff Nick Riviera Seymore Skinner Hank Scorpio Timothy Lovejoy John Frink Cletus Spuckler Ruth Powers Artie Ziff Agnes Skinner Helen Lovejoy First, we copy the text to the clipboard.\nNow we can paste and sort:\n$ pbpaste | sort Agnes Skinner Artie Ziff Artie Ziff Artie Ziff Cletus Spuckler Hank Scorpio Helen Lovejoy John Frink Kirk Van Houten Nick Riviera Ruth Powers Seymore Skinner Timothy Lovejoy Timothy Lovejoy Then remove the duplicates:\n$ pbpaste | sort | uniq Agnes Skinner Artie Ziff Cletus Spuckler Hank Scorpio Helen Lovejoy John Frink Kirk Van Houten Nick Riviera Ruth Powers Seymore Skinner Timothy Lovejoy Replace the underscore with an ampersand:\n$ pbpaste | sort | uniq | tr \u0026quot; \u0026quot; \u0026quot;_\u0026quot; Agnes_Skinner Artie_Ziff Cletus_Spuckler Hank_Scorpio Helen_Lovejoy John_Frink Kirk_Van_Houten Nick_Riviera Ruth_Powers Seymore_Skinner Timothy_Lovejoy Then add the final part of the email address:\n$ pbpaste | sort | uniq | tr \u0026quot; \u0026quot; \u0026quot;_\u0026quot; | sed 's/$/@simpsons.com/' Agnes_Skinner@simpsons.com Artie_Ziff@simpsons.com Cletus_Spuckler@simpsons.com Hank_Scorpio@simpsons.com Helen_Lovejoy@simpsons.com John_Frink@simpsons.com Kirk_Van_Houten@simpsons.com Nick_Riviera@simpsons.com Ruth_Powers@simpsons.com Seymore_Skinner@simpsons.com Timothy_Lovejoy@simpsons.com This looks perfect! We can now put the transformed text back onto the clipboard:\n$ pbpaste | sort | uniq | tr ' ' '_' | sed 's/$/@simpsons.com' | pbcopy All in all we have the following pipeline:\n pbpaste - output the clipboard sort - order the output uniq - deduplicate the rows tr ' ' '_' - replace spaces with underscores sed /$/@simpsons.com - add the email domain to the end of the row  Building this in one go is hard, let's look at little more at the pipeline.\nI hope this was useful! Please comment if you have any questions or tips. To see further articles as they come out, follow the repo at:\ngithub.com/dwmkerr/effective-shell\nOr just follow @dwmkerr on Twitter.\nThinking in Pipelines Some of these commands might be unfamiliar, some might not make sense, and you might be thinking \u0026lsquo;how would I remember that\u0026rsquo;. Actually, there are many ways to solve the problem above, this is the one I came up with by iteratively changing my input text.\nHere's what I mean - you'll see that I actually build a pipeline like this step-by-step:\n(P.S - if you are wondering how I am jumping backwards and forwards a word at a time, check the last chapter \u0026lsquo;Navigating the Command Line').\nWhat we're doing here is only possible because these simple commands all follow \u0026lsquo;the Unix Philosophy\u0026rsquo;. They do one thing well, and each command expects it's input to become the input of another command later on. Specifically:\n The commands are primitive and simple - sort is sorting a list, uniq is making elements unique. The commands don't produce unnecessary output - sort doesn't add a header such as Sorted Items, which is great because otherwise it would clutter our pipeline. We are chaining commands together, the output of one becomes the input of another.  We don't need a command such as \u0026lsquo;Take a muddy list, sort and clean it, then turn pairs of words into an email address\u0026rsquo; - with a few simple \u0026lsquo;workhorse\u0026rsquo; commands we can easily build this functionality ourselves.\nThese workhorse commands will be introduced and detailed as we go through the series. We'll also spend a lot more time looking at pipelines.\nAppendix - Clipboard Access on Linux If you are using Linux, there is no pbcopy and pbpaste commands. You can use the xclip tool to create equivalent commands.\nFirst, install xclip:\nsudo apt-get install -y xclip Then add the following to your .bashrc file:\n# Create mac style aliases for clipboard access. alias pbcopy=\u0026#34;xclip -selection c\u0026#34; alias pbpaste=\u0026#34;xclip -selection c -o\u0026#34; Obviously you can use any alias you like! The article assumes that pbcopy and pbpaste have been used.\n"});index.add({'id':10,'href':'/effective-shell/docs/section1/2-clipboard-gymnastics/examples/formatting/','title':"Formatting",'content':" Formatting   Apples Oranges Pears Apples    "});index.add({'id':11,'href':'/effective-shell/docs/section1/3-getting-help/','title':"3 Getting Help",'content':"Getting Help In this article I'll show you how to quickly get help when working with tools in the shell, without disrupting your flow!\nGetting Help is Important! If you are trying to be more effective when using the shell, it is crucial to know how to quickly look things up.\nThere'll be many circumstances where you'll need to open a browser to search for help, but there's also a wealth of information only a few keystrokes away. Looking up parameters, checking how to run commads, C library docs or useful information like ASCII charts are available directly in the system.\nBefore we look at the standard way of accessing documentation on unix-like systems, which is the man command, I'm going to introduce tldr.\nNine times out of ten I get the help I need in a few seconds with tldr, so if you take only one thing away from the article, take the first section. Then if you want to learn more about the system manuals, read on!\ntl;dr Let's say I need to find and replace some text in a file. I know I can do this with the sed command, but have forgotten the syntax.\nAll I need to do is run tldr sed:\nThe first example is exactly what I'm looking for. Now for any more detail than a few basic examples, I'm going to have to go to the manual, but it's overkill for the basics. Here's what man sed shows me:\nAnd this is just page one of six! There's a lot of detail, which is great sometimes, but for a quick lookup, tldr is perfect.\nYou can install the tldr tool with npm install -g tldr. It's open source and community maintainedFASTCACHE_TIME_ZONE\nNow a lot of the time, you are still going to need more help or more detail. For the rest of the article, we'll dive a bit deeper into man, the system manual pages.\nUnderstanding \u0026lsquo;man\u0026rsquo; Most tools you encounter in the shell have manual pages available. Many people will be familiar with the man command to get help on a tool, but let's take a look in a bit more detail, there's actually a lot more available than just the documentation for common commands.\nGetting help on a command The most basic way to get help on a command is with man. Here's an example:\n$ man cp CP(1) BSD General Commands Manual CP(1) NAME cp -- copy files SYNOPSIS cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file ... target_directory DESCRIPTION In the first synopsis form, the cp utility copies the contents of the source_file to the target_file. In the second synopsis form, the con- tents of each named source_file is copied to the destination target_directory. The names of the files themselves are not changed. If cp detects an attempt to copy a file to itself, the copy will fail. ... The man command opens the manual for the given tool. These manuals should contain all command line options and details of how to use the tool.\nYou can scroll up and down through the content with the arrow keys, this is because the information is presented in the shell pager, which is a tool for looking through content which might not easily fit on a screen.\nUsing the pager The first thing you might notice is that you can move through the manual pages with the arrow keys.\nManpages are just text files, and man opens them in a pager tool, which is what is providing the keyboard interface to look through the file.\nOn most systems, the pager will be the less program. There are lots of commands you can use to navigate through files with less, but the bare essentials are:\n d - Scroll down half a page u - Scroll up half a page j / k - Scroll down or up a line. You can also use the arrow keys for this q - Quit /\u0026lt;search\u0026gt; - Search for text n - When searching, find the next occurrence N - When searching, find the previous occurrence  There are many other commands, but the set above is normally what I find myself using the most.\nIf you are interested, you can actually see what your pager is with the command below:\n$ echo $PAGER less The $PAGER environment variable is used to tell the shell what program to use for paging. More details are found with man man.\nYou can put any text content into your pager - try this:\nls -al /usr/bin | less This lists the contents of the /usr/bin folder, piping the output to less so we can easily scroll through it.\nThere are alternative pagers available (on many Unix-y systems you'll have less, more and most) but in general you'll normally get what you need with less.\nWhat's with the numbers? You'll often see tools referred to in manpages with numbers after them. Take a look at man less:\nThe number is the manual Section Number. The different sections of the manual are documented be found on most unix-like systems in man's documentation, which you can check by running man man1. Here's what you'd get on Ubuntu 16:\n Section 1 - Executable programs or shell commands Section 2 - System calls (functions provided by the kernel) Section 3 - Library calls (functions within program libraries) Section 4 - Special files (usually found in /dev) Section 5 - File formats and conventions eg /etc/passwd Section 6 - Games Section 7 - Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7) Section 8 - System administration commands (usually only for root) Section 9 - Kernel routines [Non standard]  We'll go through the setions in detail shorltly.\nYou can specifically choose which section of the manual you are looking in by using:\nman \u0026lt;section\u0026gt; \u0026lt;search\u0026gt; You can also get more information about the sections themselves by opening up the intro page. For example:\n$ man 1 intro INTRO(1) BSD General Commands Manual INTRO(1) NAME intro -- introduction to general commands (tools and utilities) DESCRIPTION Section one of the manual contains most of the commands which comprise... Why would you do this, and why would you care? A few examples from each section show how this can be quite useful to know about.\nSection 1: Programs and Shell Commands These are programs, probably what you are going to be looking up most regularly! For example, man 1 time shows:\nTIME(1) BSD General Commands Manual TIME(1) NAME time -- time command execution SYNOPSIS time [-lp] utility DESCRIPTION The time utility executes and times utility. After the utility finishes, time writes the total time elapsed, the time consumed by system overhead, and the time used to execute utility to the standard error stream. Times are reported in seconds. ... Section 2: System Calls You'll probably not use this section unless you are doing systems programming2. This section contains info on the avaiable Linux Kernel system calls. For example, running man 2 chown gives:\nCHOWN(2) BSD System Calls Manual CHOWN(2) NAME chown, fchown, lchown, fchownat -- change owner and group of a file SYNOPSIS #include \u0026lt;unistd.h\u0026gt; int chown(const char *path, uid_t owner, gid_t group); ... Section 3: Library Calls These are the manpages for the C standard library functions. For example, man 3 time:\nTIME(3) BSD Library Functions Manual TIME(3) NAME time -- get time of day LIBRARY Standard C Library (libc, -lc) SYNOPSIS #include \u0026lt;time.h\u0026gt; time_t time(time_t *tloc); ... Here we can see why the sections are important to know about.\nRunning man time would not open the page above, because man searches the library in ascending section order, meaning that it actually finds time(1) and shows the pages for the time program, not the time C library call.\nBecause of the potential ambiguity of names if no section number is included, in lots of Linux documentation you'll see the man section number written next to library calls, system calls, programs and so on (things will refer to sed(1) or time(3) for example.\nSection 4: Devices This section deals with the special devices which live in the /dev/* folder. For example, running man 4 random shows:\nRANDOM(4) BSD Kernel Interfaces Manual RANDOM(4) NAME random , urandom -- random data source devices. SYNOPSIS pseudo-device random DESCRIPTION The random device produces uniformly distributed random byte values of potentially high quality. ... Again, we see that section numbers can be important. If you just run man random, you'll see:\nRANDOM(3) BSD Library Functions Manual RANDOM(3) NAME initstate, random, setstate, srandom, srandomdev -- better random num- ber generator; routines for changing generators LIBRARY Standard C Library (libc, -lc) SYNOPSIS #include \u0026lt;stdlib.h\u0026gt; char * initstate(unsigned seed, char *state, size_t size); long random(void); ... Which is the manpage for random(3), which is C library function, not the /dev/random file!\nSection 5: File Formats This section details special files in the system. For example, man 5 crontab shows:\nCRONTAB(5) BSD File Formats Manual CRONTAB(5) NAME crontab -- tables for driving cron DESCRIPTION A crontab file contains instructions to the cron(8) daemon of the gen- eral form: ``run this command at this time on this date''. Each user has their own crontab, and commands in any given crontab will be exe- cuted as the user who owns the crontab. Uucp and News will usually have their own crontabs, eliminating the need for explicitly running su(1) as part of a cron command. ... Which describes the crontab file used to define scheduled tasks. Again, this is different to man crontab which would document crontab(1). Similarly, man 5 passwd is going to show something quite different to man passwd.\nSection 6: Games Nothing says it better than man 6 intro itself (this'll not work on a Mac sadly, but try it on another Linux system):\n... DESCRIPTION Section 6 of the manual describes all the games and funny little programs available on the system. ... There are probably a few silly programs available on your system, here you'll find their manuals. For example, man 6 banner on a Mac shows:\nBANNER(6) BSD Games Manual BANNER(6) NAME banner -- print large banner on printer SYNOPSIS banner [-d] [-t] [-w width] message ... DESCRIPTION Banner prints a large, high quality banner on the standard output. If the message is omitted, it prompts for and reads one line of its stan- dard input. ... This section is going to be highly dependent on your OS!\nSection 7: Miscellaneous This is where you'll find additional assorted documentation. For example, man 7 ascii shows:\nASCII(7) BSD Miscellaneous Information Manual ASCII(7) NAME ascii -- octal, hexadecimal and decimal ASCII character sets DESCRIPTION The octal set: 000 nul 001 soh 002 stx 003 etx 004 eot 005 enq 006 ack 007 bel ... Section 8: System Commands We've actually already seen one of these commands mentioned, in the manpage for crontab(5) it mentions cron(8). Let's see, with man 8 cron:\nCRON(8) BSD System Manager's Manual CRON(8) NAME cron -- daemon to execute scheduled commands (Vixie Cron) SYNOPSIS cron [-s] [-o] [-x debugflag[,...]] These are commands which sysadmins would normally run. You might open section eight unexpectedly, for example man chmod will open chmod(1), but man chown will open chown(8), as it is a system command.\nSome distributions might vary for section nine. On my Mac it contains information about the kernel interfaces, a C style guide and some more.\nGetting the Index of Manual Section Manpages are just files on the filesystem, so you can get the index of a section just by looking in the appropriate folder.\nFor example, to index the available system calls, try ls /usr/share/man/man2:\nEV_SET.2 FD_CLR.2 FD_COPY.2 FD_ISSET.2 FD_SET.2 FD_ZERO.2 _exit.2 accept.2 access.2 acct.2 ... This is quick and easy way to see what sort of entries you have on your system. If you want to work out where an entry lives, use the -w flag:\n$ man -w printf /usr/share/man/man1/printf.1 Searching the Manual You can search the manpage titles and summaries with man -k. For example, man -k cpu shows:\ncpuwalk.d(1m) - Measure which CPUs a process runs on. Uses DTrace dispqlen.d(1m) - dispatcher queue length by CPU. Uses DTrace gasm(n), grammar::me::cpu::gasm(n) - ME assembler You can find more advanced options for searching by using your newfound man skills on man itself.\nThat's Enough! I'd recommend tldr as a first-call for checking to see how to use a command.\nman is a powerful tool to dive deeper into how programs and components of the system work. Like many tools which have been around for a long time, there's a lot you can do with man. Much of it you'll likely never need, so I've tried to keep this article to the basics.\nUnderstanding manpage sections is useful - you'll see them referenced again and again in documentation on the system and online.\nI hope this helps you save some time when you are working! Please let me know in the comments if you have any questions or thoughts.\nYou can also check out the rest of the effective shell series.\nAppendix: Dash As a final note, if you find yourself using man a lot because you work offline (I fly a lot so find it very helpful when on a plane with no WiFi), you should also look at Dash3.\nDash is simply an offline documentation aggregator. It can download online manuals for many, many different programming languages, frameworks, technologies and so on. I actually have a vim keyboard command to open the word under the cursor in dash, with the documentation automatically set based on the type of the file.\nThis is super-useful if you are offline at lot and need more sophisticated offline documentation. You can find out more about it at https://kapeli.com/dash.\nFootnotes   Weirdly satisfying to run. \u0026#x21a9;\u0026#xfe0e;\n Which it is always fun to try if you get the chance, and a great way to learn more about the fundamentals of the operating system. \u0026#x21a9;\u0026#xfe0e;\n Dash is a paid product. Full disclosure - I don't get any money from them or anyone else to write about anything, all content is 100% based on my experiences. I don't run ads on my site either. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':12,'href':'/effective-shell/docs/section1/4-moving-around/','title':"4 Moving Around",'content':"Moving Around You might already spend a lot of time in the shell, running various command line programs or using tooling for development projects or operational tasks. But you might also still switch back to a more visual paradigm for working with files, directories and resources.\nBeing able to perform everyday file and folder manipulation tasks directly from the shell can really speed up your workflow. Let's look at some common tasks and see how we can work with them in the shell. Along the way we'll also introduce some of the most frequently used tools and commands to work with the filesystem.\nWhere Am I? The first command to become familiar with is pwd (\u0026lsquo;print working directory\u0026rsquo;). This command will echo the current absolute path. You can also use the $PWD environment variable:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ echo $PWD /Users/dave/repos/github/dwmkerr/effective-shell Depending on your shell, or your command-line setup (which we will discuss in a later chapter), you might also see your working directly on the command-line.\nChanging Directory Most likely one of the most familiar commands out there, the cd or chdir function changes the current directory:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ cd $ pwd /users/dave $ cd - ~/repos/github/dwmkerr/effective-shell $ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ cd ~ $ pwd /users/dave Here we can see that running cd with no parameters moves to the users \u0026lsquo;home\u0026rsquo; directory. This directory is always available in the $HOME environment variable.\nRunning cd - will switch back to the previous directory — this is very useful if you want to quickly jump somewhere and then back again.\nYou can use ~ as an alias for the home directory, allowing you to quickly move to personal folders, with commands such as cd ~/Downloads.\nMost commonly, you will specify a path when changing directory. This can be a fully qualified path, or it can be a relative path:\n$ cd /dev $ cd ~/repos $ cd ./github You can use the special link .., which is a folder that points to the parent directory to move \u0026lsquo;upwards\u0026rsquo;:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ cd ../../ $ pwd /Users/dave/repos/github Exploring a Directory Once we are in a directory, we will often want to see the contents. The ls (\u0026ldquo;list directory contents\u0026rdquo;) command is useful here:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell $ ls 1-navigating-the-command-line LICENSE 2-clipboard-gymnastics README.md 3-getting-help sed.1 4-moving-around By default, the ls command will list the files and directories. We can show more information with the -l (\u0026ldquo;long format\u0026rdquo;) flag:\n$ ls -l total 48 drwxr-xr-x 6 dave staff 192 Mar 5 16:01 1-navigating-the-command-line drwxr-xr-x 5 dave staff 160 Oct 10 2017 2-clipboard-gymnastics drwxr-xr-x 4 dave staff 128 Dec 19 2017 3-getting-help drwxr-xr-x 3 dave staff 96 Mar 7 15:39 4-moving-around -rw-r--r-- 1 dave staff 1066 Jun 10 2017 LICENSE -rw-r--r-- 1 dave staff 561 Mar 7 15:30 README.md -rw-r--r-- 1 dave staff 15707 Mar 5 16:01 sed.1 Now we can see the permissions, the link count (which is rarely particularly useful and varies from platform to platform), the owner, the group, the size and the modification date (as well as the name).\nWe can make the sizes more human readable, and sort by size with a few more flags -h (\u0026ldquo;human readable\u0026rdquo;) and -s (\u0026ldquo;sort by size\u0026rdquo;):\n$ ls -lhS total 48 -rw-r--r-- 1 dave staff 15K Mar 5 16:01 sed.1 -rw-r--r-- 1 dave staff 1.0K Jun 10 2017 LICENSE -rw-r--r-- 1 dave staff 561B Mar 7 15:30 README.md drwxr-xr-x 6 dave staff 192B Mar 5 16:01 1-navigating-the-command-line drwxr-xr-x 5 dave staff 160B Oct 10 2017 2-clipboard-gymnastics drwxr-xr-x 4 dave staff 128B Dec 19 2017 3-getting-help drwxr-xr-x 3 dave staff 96B Mar 7 15:39 4-moving-around There are lot of options for ls. Check the chapter Getting Help for some tips on how to get more information on a command!\nManaging the Directory Stack You might find that you want to move to a number of directories, then return to where you started. This can be particularly useful when scripting. You can use the pushd (\u0026ldquo;push onto directory stack\u0026rdquo;) and popd (\u0026ldquo;pop from directory stack\u0026rdquo;) commands to add or remove directories from the stack:\n$ pwd /Users/dave/repos/github/dwmkerr/effective-shell # OK - I\u0026#39;m writing my article at the moment, but want to check my downloads, and come back shortly... # Move to the downloads folder... $ ls aws-nuke-v2.8.0-darwin-amd64 # OK cool - the tool I was downloading has arrived, let\u0026#39;s use it... cd aws-nuke-v2.8.0-darwin-amd64 ./aws-nuke # Now I want to go back to my article... $ popd ~/Downloads ~/repos/github/dwmkerr/effective-shell ~/Downloads $ popd ~/repos/github/dwmkerr/effective-shell In this case, using cd - would not be sufficient — that would just switch us from the aws-nuke folder to Downloads and back again. But by using the directory stack we can save where we are, move, and then \u0026lsquo;pop\u0026rsquo; our way back to where we started.\nAuto-Completion Pressing tab when using commands like cd will generally show an auto-completion menu:\n$ cd ~/repos/ # press \u0026#39;tab\u0026#39; now... github/ gitlab/ local/ scratch/ Pressing tab again will cycle through options, and shift-tab will cycle backwards. Enter will select an option, escape (or Ctrl-C) will cancel.\nSome shells, such as zsh, support even more advanced auto-completion. For example, we can auto-complete to fill in partially specified directory names:\n% cd ~/r/g/d/e # press tab now...\u000c% cd ~/repos/github/dwmkerr/effective- effective-container-engineering/ effective-shell/ Auto-completion is generally very shell specific. We'll look more into the different shells that are available in later chapters. But in general, if you are uncertain, pressing tab will often show a sensible set of options.\nThat's It! This is a small chapter, but an important one. Later on, as we start to do more file and system manipulation from the shell, moving and copying files and so on, we will build on these concepts. But it is critical to first know the basics of how to move around the filesystem with the shell.\n"});index.add({'id':13,'href':'/effective-shell/docs/section1/5-what-is-a-shell/','title':"5 What Is a Shell",'content':"his is the first \u0026lsquo;interlude\u0026rsquo; in my Effective Shell series. These interludes give some background, history or more flavour to some of the topics.\n Part 1: Navigating the Command Line Part 2: Become a Clipboard Gymnast Part 3: Getting Help Part 4: Moving Around Interlude: Understanding the Shell  This one should be high-level enough for even non-technical readers to enjoy (or at least understand!). I've tried to make sure any term that might be unfamiliar is described in a footnote1. For the more technical reader, it provides an important grounding on some of the key concepts relating to shells and how they work.\nIntroduction for the Non-Technical Reader It might come as a surprise that many technical computer users (programmers, data scientists, systems administrators etc) spend a lot of time using an interface which looks like it's from the sixties:\nIf you work with technologists, you might have seen them using an interface like this. This kind of simple, text-based interface is called a shell, and it has been a common way to interface with computers ever since the first screens and keyboards were created.\nGiven how much computing has advanced, why would people use such an interface? Just look at how much the Windows operating-system has changed over the last three decades:\n(By Source (WP:NFCC#4), Fair use, https://en.wikipedia.org/w/index.php?curid=58853841)\nWhy would people choose to use such an archaic interface as a shell?\n Typing is fast: A skilled shell user can manipulate a system at dazzling speeds just using a keyboard. Typing commands is generally much faster than exploring through user interfaces with a mouse Shells are programmable: Users will often being programming as they work in a shell, creating scripts to automate time-consuming or repetetive processes Shells are portable: A shell can be used to interface to almost any type of computer, from a mainframe to a Raspberry Pi, in a very similar way.  Not all technical users will use a shell regularly, but there are many who will spend the bulk of their time in such an interface. It is such a crucial skill to be able to operate one effectively that I have been writing this series primarily to show ways to be more efficient with this kind of interface.\nIntroduction for the Technical Reader You may be familar with the shell, but it can be useful to understand some of the surrounding concepts in detail. How does a shell differ from a terminal? What is a tty? How do shells really work? Hopefully as you read this article you'll discovery something that you didn't know about shells.\nLet's Get Started! To understand what shells, terminals, command-prompts and so on are and how they relate, we need to start with the basics: how a modern computer works!\nA Computer in a Nutshell The diagram below shows a simplified view of a typical computer:\nAlready there's a lot going on.\nYour computer is going to have a CPU2 and memory3, and almost certainly a network adapter4 and display adapter5. Most computers will have at least one hard disk. For home PCs, there'll also likely be a bunch of peripherals, such as a mouse, keyboard, printers, flash drives, webcams and so on.\nThe Operating System The operating system is the piece of software installed on a computer that can interface with the hardware. Without hardware, such as a CPU, memory, a network adapter, a graphics card, disk drives and so on, there's not much that you can do with the computer. The operating system is the primary interface to this hardware. No normal programs will talk to hardware directly - the operating system abstracts this hardware away and provides a software interface to it.\nThe abstraction the operating system provides is essential. Developers don't need to know the specifics of how to work with individual devices from different vendors; the operating system provides a standardised interface to all of this. It also handles various tasks such as making sure the system starts up properly.\nThe operating system is generally broken down into two parts - the kernel and user space:\nLet's look at these in more detail.\nThe Kernel This is the part of the operating system that is responsible for the most sensitive tasks: interfacing with physical devices, managing the resources that are available for users and programs, starting up the various systems that are needed, and so on.\nSoftware running in the kernel has direct access to resources, so is extremely sensitive. The kernel will balance resources between the programs in user space, which we'll look at shortly. If you've ever had to install \u0026lsquo;drivers\u0026rsquo;, these are examples of pieces of software that will run in the kernel - they'll have direct access to a physical device you've installed, and expose it to the rest of the software on the computer.\nWhy \u0026lsquo;kernel\u0026rsquo;? The kernel is the soft, edible part of a nut or seed, which is surrounded by a shell. Below you can see a walnut - the kernel is the soft bit in the middle, and the shell surrounds and protects it. This is a useful metaphor that is used for parts of a computer.\n(By Kkchaudhary11 - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=49069244)\nThe operating system kernel really is the core of the operating system. It's such a sensitive area of the operating system that we actually want to avoid running software in it if possible6. And that is where user space comes in.\nUser Space The vast majority of programs run in \u0026lsquo;user space\u0026rsquo; (also commonly called \u0026lsquo;user land\u0026rsquo;).\nWhen a program starts, the kernel will allocate it a private segment of memory and provide limited access to resources. The program is given access to a library of functions by the operating system, which it can use to access resources such as files, devices and so on. Programs in user space are essentially in sandboxes, where there is a limit to how much damage they can do.\nFor example, a program running in user space can use the standard fopen function, which is provided on almost every operating system as part of the C Standard Library. This allows a program to attempt to open a file. The operating system will make a decision on whether the program is allowed to open the file (based on things such as permissions, where the file is and so on) and then, if it is OK with the call, will give the program access to the file. Under the hood, this \u0026lsquo;user space\u0026rsquo; call translates to a system call in the kernel.\nNow that the key components have been introduced, we can look at the shell. The name should come as no surprise, as it is a wrapper or outer layer to the operating system (which itself contains the sensitive nugget of the kernel).\nThe Shell So what is the shell? The shell is just a general name for any user space program that allows access to resources in the system, via some kind of interface.\nShells come in many different flavours but are generally provided to aid a human operator in accessing the system. This could be interactively, by typing at a terminal, or via scripts, which are files that contain a sequence of commands.\nFor example, to see all of the files in a folder, the human operator could write a program in a language such as C, making system calls to do what they want. But for day-to-day tasks, this would be repetitive. A shell will normally offer us a quick way to do that exact task, without having to manually write a program to do it.\nHere's an example, where a shell is being used to show the \u0026lsquo;png\u0026rsquo; images in the folder I am working in7:\nSo a shell is a user-space program to interface with the computer. But there a few more moving parts than just a shell we are seeing in the image above. There are different types of shells, there are terminal programs, and there are the programs or commands that the shell calls (in the example above, tree is a program). Let's pick these apart.\nHere's a diagram that more accurately shows what is going on:\nWe've introduced a few new things here. There's a user, who is interfacing with a terminal, which is running a shell, which is showing a command prompt. The user has written a command that is calling a program (in this case, the tree program).\nLet's dissect this bit by bit.\nThe Terminal We're not directly interacting with the \u0026lsquo;shell\u0026rsquo; in this diagram. We're actually using a terminal. When a user wants to work with a shell interactively, using a keyboard to provide input and a display to see the output on the screen, the user uses a terminal.\nA terminal is just a program that reads input from the keyboard, passes that input to another program (normally a shell), and displays the results on the screen. A shell program on its own does not do this - it requires a terminal as an interface.\nWhy the word terminal? This makes sense when you look at how people interfaced with computers historically. Input to a computer might be through punch cards, and output would often be via a printer. The Teletype Termimal8 became a common way for users to interface with computers.\n(Photograph by Rama, Wikimedia Commons, Cc-by-sa-2.0-fr, CC BY-SA 2.0 fr, https://commons.wikimedia.org/w/index.php?curid=17821795)\nAt this time, computers were very large, complex, and expensive machines. It was common to have many terminals connected to a single large machine (or \u0026lsquo;mainframe\u0026rsquo;), or a few terminals that people would share. But the terminal itself was just a human interface to the operating system. A more modern terminal would be something like an IBM 3486:\n(By ClickRick - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=6693700)\nThis is a very small computer in its own right but still basically just a dumb screen and keyboard connected by a cable to a larger mainframe computer in another location.\nThis mechanism is still very much the case today. When I want to work with a computer in a data centre, I don't go and find the machine, plug in a keyboard and a display and directly interface to it. I run a terminal program on my computer to provide access to the remote machine. My terminal program allows me to use my keyboard and display to work with a remote machine - all via a secure shell - which is a secured-shell connection over a network.\nSo terminals in many ways are quite simple - they are interfaces. But because they are quite simple programs, we can't do much with them. So normally, the first thing that a terminal program will do is run a shell program - a program that we can use to operate the computer.\nThere's nothing special about terminals - anyone can write a program to operate as a terminal, which is why you will see many different terminals around. Examples are the standard \u0026lsquo;terminal\u0026rsquo; app for MacOS X, the gnome-terminal for Linux, and iTerm2 and Hyper. There's a bunch of screenshots of different setups at the end of the article.\nBack to the Shell Now that we've described the terminal, we can go back and look at the shell in detail.\nThe shell is the program that is going to take input from somewhere and run a series of commands. When the shell is running in a terminal, it is normally taking input interactively from the user. As the user types in commands, the terminal feeds the input to the shell and presents the output of the shell on the screen.\nA shell program can also take input from files; these files will then generally be \u0026lsquo;shell scripts\u0026rsquo;. This might be used to run automated operations, such as cleaning up certain folders when a computer starts.\nShells can write output to files or other locations, and so on. You can run a shell program outside of a terminal - you just won't be able to interface with it using a keyboard or display. And in fact, lots of operations happen in this way: automated scripts, startup tasks, installers and so on.\nSo what else does a shell do? Most of the features are related to helping human operators work with the system more efficiently.\n Quickly enter commands, see the history of commands and quickly restructure commands (see Effective Shell - Navigating the Command Line) Navigate through the file system, moving from folder to folder (see Effective Shell - Move Around!), which makes it easier for an operator to navigate the file system. Chain the output of commands together - for example, taking the output of one basic program, such as the tree program we saw, and writing it to a file (see Effective Shell - Understanding Pipelines) Offer a programming language, allowing the operator to perform more complicated tasks (see Effective Shell - Basic Shell Scripting)  And a lot more! In fact, that's what the whole Effective Shell series is about - how to get the most from these powerful programs, particularly for those who use them regularly.\nThe Command Prompt or Command Line The last part of the diagram, which we haven't covered yet, is the command prompt.\nWhen a shell is running in terminal, it knows that a human operator will be interfacing with it. So to make sure that the operator has some kind of visual hint that they have to enter commands, the shell will output some kind of prompt.\nI've included a set of screenshots at the end of the article, just after this section, and you can see how some different command prompts look.\nNote that shells don't have to use command prompts - if you use a shell program to execute a script, there will be no command prompt. Shells only show a prompt when they know they are being used interactively. Many programs which allow a user to operate interactively will show a command prompt.\nShell command prompts can be customised, so they will often look different from machine to machine (for more details, see Effective Shell - Customising the Command Line). Below is an example that shows a lot of technical information. This is from the highly popular oh-my-zsh framework for the \u0026lsquo;Z Shell\u0026rsquo; shell, which is very popular among developers:\n*(Source: https://ohmyz.sh/)\nShell Commands and Different Shells A lot of the \u0026lsquo;commands\u0026rsquo; in a shell, such as cat (which shows the contents of a file), are actually just simple programs, which will interface with the kernel. No matter what shell you use, these commands will behave the same way, because really all you are doing is calling another progam.\nSome commands, such as cd (change directory), are built into the shell. Some commands are functions that have been defined, or aliases to other commands (for more details on commands, see Effective Shell - Commands). Commands will often differ between shells.\nNot all shells are created equal - anyone can write a shell program, maybe creating a simple interface to the computer or a highly complex one with many features. In fact, a later article in this series will look at the geneology of the most common shells.\nOn most Unix-like systems, the default shell is a program called bash, which stands for \u0026quot; Bourne Again Shell\u0026rdquo; (the name and history around it will be discussed at length in the later article). But there are many other shells: the C Shell, the Korn Shell, Z Shell and Fish, just to name just a few.\nUsers and administators can configure what shell they like to use. When a terminal opens, it will immediately start the user's preferred shell program. It is possible to change this. Different users will have different preferences, given that shells offer varying features. This can cause complexity when working with systems, as we cannot always expect every user to have the same shell, or even for the same shell to be set up consistently, as they can be extensively customised.\nLet's review the earlier diagram again:\nWe can see the real internals of what is going on in this \u0026ldquo;Terminal -\u0026gt; Shell -\u0026gt; Program\u0026rdquo; chain in the diagram above quite easily.\nTry the command pstree -psa $$ in a shell9:\nThe first systemd process is the primary process for the OS - it is process number 1, which initialises everything else. The second systemd process is the process that is running the interface for my user. We can ignore these for now; they are internals to how the operating system boots and starts processes.\nWhat is interesting is that we can see a terminal (the gnome terminal), which has started my preferred shell (which is zsh), which is running a command (the program pstree). Here we can see the exact chain as shown in the diagram earlier.\nThat's a Wrap! These are the key technologies and concepts that surround a shell.\nIf you are interested in more technical details of working with shells, then my Effective Shell series goes into these topics in depth. The goal of this series is to help teach techniques that making working with shells more efficient.\nTo close the article, below are some examples of different terminals, shells, command prompts and so on.\nExample: iTerm 2 / tmux / zsh In this example, we have:\n A MacOS operating system iTerm2 as the terminal program tmux running as a \u0026lsquo;terminal multiplexer\u0026rsquo; (see Effective Shell: Terminal Multiplexers) zsh (Z Shell) as the shell program, using \u0026lsquo;oh my zsh\u0026rsquo;, which is easily recognised by the % sign in the command prompt. A customised command line, which shows the user and folder on one line, with only the % symbol below, to leave lots of space for the input commands10.  Example: Bash In this example, we have:\n A Linux operating system (Ubuntu 14) The gnome terminal bash as the shell In the second screenshot, the user has \u0026lsquo;root privileges\u0026rsquo;, and to indicate this, bash helpfully changes the default command prompt from a dollar sign to a hash sign  Example: Windows Explorer In this example, we have:\n The Windows 10 operating system No terminal The explorer.exe program showing us a graphical shell  This looks different from previous examples. The program, which shows the familiar Windows interface, explorer.exe, is in fact a shell as well, offering interactive access to the operating system and computer resources. The bulk of the Windows APIs to interact with this interface are in the Shell Library. I also maintain a popular library for building extensions to the graphical Windows shell - sharpshell.\nExample: Windows Command Prompt In this example, we have:\n The Windows 10 operating system The command prompt terminal and shell  In Windows, the terminal and shell are combined into a single cmd.exe program. There's an excellent article on the internals - Microsoft DevBlogs: Windows Command-Line: Inside the Windows Console\nExample: Windows PowerShell In this example, we have:\n The Windows 10 operating system The PowerShell terminal  PowerShell is an improvement on the \u0026lsquo;command prompt\u0026rsquo; program that was originally used in Windows, offering much more functionality for scripting and other modern shell features.\nExample: Windows Subsystem for Linux (WSL) In this example, we have:\n The Windows 10 operating system The Bash.exe program  This screenshot, from MSDN: Frequently Asked Questions about Windows Subsystem for Linux shows Bash running in Windows. This is a relatively new feature at the time of writing, allowing Windows users to use a Linux interface to the PC. This is a feature that may become increasingly valuable, as in general it is challenging to write shell code that can run on Windows and Unix-like systems.\nShare and Discuss If you enjoyed this article, please do share it! Feel free to include suggestions, improvements or corrections in the comments below.\n Useful References\n A simple Linux kernel module, showing how basic kernel programming works in Linux: github.com/dwmkerr/linux-kernel-module How Linux Works - Brian Ward StackExchange: What is the exact difference between a \u0026lsquo;terminal\u0026rsquo;, a \u0026lsquo;shell\u0026rsquo;, a \u0026lsquo;tty\u0026rsquo;, and a console? Microsoft: Inside the Windows Console   Footnotes\n  I'd be fascinated to know if this is at all interesting to less technically inclined people, so please do go ahead and let me know in the comments! \u0026#x21a9;\u0026#xfe0e;\n CPU: central processing unit. This is the chip in the computer that does most of the work (which after many layers of abstraction eventually becomes arithmetic and sending simple instructions to other places). \u0026#x21a9;\u0026#xfe0e;\n Memory is the \u0026lsquo;working space\u0026rsquo; where the state of your system is stored. If you are writing a document, the text lives in memory, until you save it, when it then gets written to a hard drive. Memory is ephemeral - everything is gone when you turn off the power to it. \u0026#x21a9;\u0026#xfe0e;\n This is the part of your computer that knows how to do things like connect to a WiFi network, or has a network socket you might plug a network cable into. \u0026#x21a9;\u0026#xfe0e;\n This is the part of your computer you plug the screen into. \u0026#x21a9;\u0026#xfe0e;\n This is because a mistake in Kernel Mode programs can have disasterous effects. It could access any files, no matter who they belong do, control the hardware, install more software - almost anything. Errors in this code can cause terrible issues (like the infamous Windows \u0026lsquo;blue screen of death\u0026rsquo;), and malicious code in the kernel essentially has full access to not only all your data but also your webcam, network adapter and so on. \u0026#x21a9;\u0026#xfe0e;\n As an aside, if you are curious about the visual style of my setup or customisations that have been made, everything in my setup is available online on my \u0026lsquo;dotfiles\u0026rsquo; repo - github.com/dwmkerr/dotfiles. \u0026#x21a9;\u0026#xfe0e;\n And that's where the \u0026lsquo;TTY\u0026rsquo; acronym you will see sometimes comes from. Enter the ps command, and you'll actually see the TTY interface each process is attached to. This is a topic that will come up later in the series. \u0026#x21a9;\u0026#xfe0e;\n $$ is a Bash internal variable. These will also be covered in a later article in the series. \u0026#x21a9;\u0026#xfe0e;\n Feel free to see my dotfiles to configure a similar setup for yourself. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':14,'href':'/effective-shell/docs/section1/5-what-is-a-shell/hack-on/','title':"Hack On",'content':"Hack On! See those system calls! I mentioned earlier on that if you make a call like fopen, the Kernel is going to provide access to a file. It's quite easy to see this in action. Check the code below:\n#include \u0026lt;stdio.h\u0026gt; void main() { void* handle = fopen(\u0026#34;/tmp/some-file\u0026#34;); fwrite(handle, \u0026#34;some text\u0026#34;); fclose(handle); } If you compile this program, then run XXX you will see the actual calls made to the Kernel. It can be very useful to use this technique to see what is going on with programs under the hood, particularly when diagnosing issues.\nHack On! Ahah! So that's TTY? Consider a command like:\ndocker -it Consider a command like:\nssh user@remote.com my-script no tty Once you understand the concept of shells and terminals in a bit more detail, more obscure messages like this start to make sense.\nIn the first instance, we are telling Docker we are interactive - i.e. we are going to use an interface to send commands. The second parameter, -t says use a TTY - which is short for teletype terminal, old fashioned lingo for the screen.\nTODO TTY picture\nTODO Summmary; technical For technical readers, there's quite a lot of terms which get thrown about almost interchangeably; shell, command-line, terminal, tty, command-prompt, CLI and so on. But each of these have a very specific meaning. It's important to understand exactly what each of these terms really means, where they came from, and how these different types of system or concept relate to each other.\nSummary; non-tech A computer in a nutshell.\n \u0026ndash; Could link to other layers of abstractions - such as sandboxes in webpages? \u0026ndash; Could link to other layers of abstraction, such as containers?\n"});index.add({'id':15,'href':'/effective-shell/docs/section2/6-job-control/','title':"Index",'content':"Job control is a feature of most shells, which is generally not particularly intuitive to work with. However, knowing the basics can help prevent you from getting yourself into a tangle, and can from time to time make certain tasks a little easier.\nIn this chapter, we'll look at the main features of job control, why it can be a problematic, and some alternatives.\n Part 1: Navigating the Command Line Part 2: Become a Clipboard Gymnast Part 3: Getting Help Part 4: Moving Around Part 5: Interlude - Understanding the Shell Part 6: Everything You Don't Need to Know About Job Control  What Is Job Control? Let's start with an example. I am building a simple web page. It has one index.html file, one styles.css file, and one code.js file. The index.html file looks like this:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My New Project\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;code.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--Snip... --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Opening the file in a browser doesn't quite work, as it won't load the code or the styles. We need a web server to serve styles and code.\nA super-useful one-liner to run a web server on any machine with Python installed is:\npython -m SimpleHTTPServer 3000 In fact, this is so useful that I normally alias this command, so that I can just type serve. We'll see aliases in a later chapter.\nFor now, if we run this command (you can get the three sample files here if you want to try this yourself), then we can open the webpage in a browser, with the styles and code loaded:\nWe can also see that the server has served the HTML, JavaScript, and CSS files:\nAll well and good so far.\nThe Problem Let's say we want to now continue using our shell, maybe to edit the website with a terminal editor like Vim or Emacs, or we want to zip up the site, or just run any shell command1.\nWe have a problem. The python process is still running - it's serving the website. Our shell is essentially useless, until we stop the server. See what happens when I try to edit a file:\nIn the example above, I try to run vi, but nothing is happening. Standard input is not being read by the server and not being interpreted by the shell.\nI have to kill the server by hitting Ctrl+C (which sends a SIGINT2 - we'll see more about signals later), clear my screen to get rid of all of the error messages, then start again.\nThis is obviously not optimal. Let's look at some solutions.\nSolution 1: Start the Server in the Background In most shells, you can run a command and instruct the shell to run it in the background. To do this, you end the line with an ampersand. Here's how the example would look in this case:\nBy ending the command with an \u0026amp; ampersand symbol, we instruct the shell to run the command as a background job. This means that our shell is still functional. The shell has also notified us that this command is running as a background job with a specific job number:\n% python -m SimpleHTTPServer 3000 \u0026amp; [1] 19372 In slightly obtuse language, the shell has informed us that it has started a job in the background, with job number 1 and that this job is currently handling the process with ID 19372.\nThe ampersand solution is a fairly common pattern used in day-to-day work.\nSolution 2: Move the Server to the Background Let's say you forgot to start the command in the background. Most likely in this case you'd kill the server with Ctrl+C and then start it again with the \u0026amp; option. However, what if this was a large file download or a task you didn't want to abort?\nIn the example below, we'll move the job to the background:\nThe process is currently in the foreground, so my shell is inactive. Hitting Ctrl+Z sends a \u0026lsquo;suspend\u0026rsquo; signal to the process3, pausing it and moving it to the background.\nLet's dissect this:\n% python -m SimpleHTTPServer 3000 Serving HTTP on 0.0.0.0 port 3000 ... 127.0.0.1 - - [03/Jun/2019 13:38:45] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - ^Z [1] + 21268 suspended python -m SimpleHTTPServer 3000 The shell echos as I type, so we see ^Z (i.e., the Ctrl+Z chord I entered). The shell responds by moving the process into a background job and suspending it.\nThe key here is that it is suspended. The process is paused. So the web server is no longer serving. If you are following with the sample, reload your browser. The webpage fails to load, as the server process is not able to respond to requests.\nTo continue the job, in the background, we use the bg (\u0026lsquo;background\u0026rsquo;) command, with a job identifier (which always starts with a % symbol - we'll see why soon) to tell the shell to continue the job:\n% bg %1 [1] + 21268 continued python -m SimpleHTTPServer 3000 The shell lets us know the job is being continued, and if we load the webpage again, the content is shown as expected.\nAs a final check, we run the jobs command to see what jobs the shell is running:\n% jobs [1] + running python -m SimpleHTTPServer 3000 And there you have it - our server is running as a background job. This is exactly what we would see if we run jobs after starting the server with an \u0026amp; at the end. In fact, using an \u0026amp; is perhaps an easier way to remember how to continue a suspended job:\n% %1 \u0026amp; [1] + 21268 continued python -m SimpleHTTPServer 3000 In the same way ending a command with \u0026amp; runs it in the background, ending a job identifier with \u0026amp; continues it in the background.\nThere is at least one more way to move a job to the background4, but I have not yet found it useful in any scenarios, and it is overly complex to explain. See the footnote for details if you are interested.\nMoving Background Jobs to the Foreground If you have a job in the background, you can bring it back to the foreground with the fg (\u0026lsquo;foreground\u0026rsquo;) command. Let's show the jobs, with the jobs command:\n% jobs [1] + running python -m SimpleHTTPServer 3000 Here I have a background job running a server. Any one of the following commands will bring it back to the foreground:\nfg %1 # Explicitly bring Job 1 into the foreground %1 # ...or in shorthand, just enter the job id... fg # ...if not given an id, fg and bg assume the most recent job. Now the job is in the foreground, and you can interact with the process again however you like.\nCleaning Up Jobs You might realise you cannot continue what you are doing because an old job is still running. Here's an example:\nI tried to run my web server, but there was still one running as a background job. The server failed to start because the port is in use.\nTo clean it up, I run the jobs command to list the jobs:\n% jobs [1] + suspended python -m SimpleHTTPServer 3000 There's my old web server. Note that even though it is suspended, it'll still be blocking the port it is serving on5. The process is paused, but it is still holding onto all of the resources it is using.\nNow that I know the job identifier (%1 in this case), I can kill the job:\n% kill %1 [1] + 22843 terminated python -m SimpleHTTPServer 3000 This is why job identifiers start with a percentage sign! The kill command I have used is not a special job control command (like bg or fg). It is the normal kill command, which terminates a process. But shells that support job control can normally use a job identifier in place of a process identifier. So rather than working out what the process identifier is that I need to kill, I can just use the job identifier6.\nWhy You Shouldn't Use Jobs Avoid jobs. They are not intuitive to interface with, and they suffer from some serious problems.\nThe most obvious one is that all jobs write to the same output, meaning you can quickly get garbled output like this:\nThis is what happens when I run a job, which just outputs text every second. It's in the background, but it's printing all over my commands. Even running the jobs command to try and find the job to stop it is difficult.\nInput is even more complex. If a job is running in the background, but requires input, it will be silently suspended. This can cause confusion.\nJobs can be used in scripts but must be done so with caution and could easily confuse a consumer of the script if they leave background jobs hanging around, which cannot be easily cleaned up7.\nHandling errors and exit codes for jobs can be problematic, causing confusion, poor error handling, or overly complex code.\nHow to Escape Jobs If there are two things to take away, it would be this:\n If you have started running a command in the foreground, and you don't want to stop it and would rather move it to the background, hit Ctrl+Z. Then Google \u0026ldquo;job control\u0026rdquo;.\n And:\n If you think there is a job running in the background, and it is messing with your screen, type fg to bring it to the front and kill it with Ctrl+C. Repeat as needed!\n In either case, if you need to do something more subtle, you can return to this reference. But the first command should allow you to get your shell back while you work out how to continue the job, and the second should kill a background job that is messing with your screen.\nAlternatives to Jobs If you are using any kind of modern terminal such as iTerm, Terminal or the GNOME Terminal, just open a new tab or split! Much easier.\nThe benefit to this is that each tab gets its own standard input and output, so there's no risk of overwriting. And of course you can hide/reveal/rearrange the tabs however you like.\nThe traditional alternative to a job for an operator who simply wants more than one thing going on at once would be a terminal multiplexer, such as screen or tmux:\nMultiplexers work in a very similar way to a modern graphical terminal - they manage many shell instances. The benefits to a modern terminal, such as iTerm, is that you have a very intuitive GUI and lots of features.\nThe benefits to a multiplexer are that you can run them over SSH sessions to manage complex operations on remote machines and that they run a client-server model, meaning many people can work with many multiplexed processes (and they can persist beyond sessions).\nMy personal preference is both - I use a modern terminal and run everything inside it in tmux. We'll look at both of these options in later chapters.\nQuick Reference You might find that jobs are useful, or you might find that they are not. Either way, here's a quick reference of some common commands:\n   Command Usage     command \u0026amp; Run the command as a background job.   \u0026lt;Ctrl+Z\u0026gt; Move the current process into a background job, suspended.   jobs List all jobs.   fg %1 Move background job number 1 into the foreground.   bg %1 Continue background job number 1.   kill %1 Terminate job number 1.   wait %1 Block until job number 1 exits.    If you want to find out more about the gory details of jobs, the best place to start is the Bash Manual - Job Control Section, or the \u0026lsquo;Job Control\u0026rsquo; section of your preferred shell's manual.\nI hope you found this useful, and, as always, please leave comments, questions or suggestions below!\n Footnotes   If you are not a heavy shell user, this might seem unlikely. But if you do a lot of work in shells, such as sysadmin, devops, or do your coding from a terminal, this happens all the time! \u0026#x21a9;\u0026#xfe0e;\n Signals like SIGINT, SIGKILL, SIGTERM and so on will be covered in a later chapter. \u0026#x21a9;\u0026#xfe0e;\n Technically, SIGTSTP - which is \u0026lsquo;TTY stop\u0026rsquo;. If you have always wondered about the \u0026lsquo;TTY\u0026rsquo; acroynm, check the previous chatper, Interlude: Understanding the Shell. \u0026#x21a9;\u0026#xfe0e;\n The alternative method is to use Ctrl+Y, which will send a delayed interrupt, which will continue to run the process until it tries to read from stdin. At this point, the job is suspended and the control given to the shell. The operator can then use bg or kill or fg to either move to the background, stop the process, or keep in the foreground as preferred. See: https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Job-Control \u0026#x21a9;\u0026#xfe0e;\n Another super-useful snippet: lsof -i -P -n | grep 8000 to find any process that has a given port open. Another one for the aliases chapter! \u0026#x21a9;\u0026#xfe0e;\n There are times this is needed. If a job runs many processes - for example, by running a pipeline - the process identifier will change as the command moves from one stage of the pipeline to the next. The job identifier will remain constant. Remember, a job is a shell command, so could run many processes. \u0026#x21a9;\u0026#xfe0e;\n To see how bad this can be, create a script that starts jobs, then run it. Then run the jobs command to see what is running. The output might surprise you! \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':16,'href':'/effective-shell/docs/section2/7-understanding-commands/','title':"Index",'content':"In this chapter, we'll take a look at the various different types of shell commands that exist and how this can affect your work.\nBy the end of this chapter, you might even be able to make sense of the horrifying and perfectly syntactically valid code below:\nwhich $(where $(what $(whence $(whereis who))))  Part 1: Navigating the Command Line Part 2: Become a Clipboard Gymnast Part 3: Getting Help Part 4: Moving Around Part 5: Interlude - Understanding the Shell Part 6: Everything You Don't Need to Know About Job Control Part 7: The Subtleties of Shell Commands  What Are Commands? This is really important to understand! A command in a shell is something you execute. It might take parameters. Generally it'll have a form like this:\ncommand param1 param2 We've already seen many commands during this series:\nls # Show the contents of the current directory cd ~ # Move to the user\u0026#39;s home cat file.txt # Output the contents of \u0026#39;file.txt\u0026#39; to stdout But to be an effective shell user, you must understand that not all commands are created equal. The differences between the types of commands will affect how you use them.\nThere are four types of commands in most shells:\n Executables \u0026ldquo;Built-Ins\u0026rdquo; (which we'll just call builtins from now on) Functions Aliases  Let's quickly dig in and see a bit more.\nExecutables - Programs Executables are just files with the \u0026lsquo;executable\u0026rsquo; bit set1. If I execute the cat command, the shell will search for an executable named cat in my $PATH. If it finds it, it will run the program.\n$ cat file.txt This is a simple text file What is $PATH? $PATH is the standard environment variable used to define where the shell should search for programs. If we temporarily empty this variable, the shell won't find the command:\n$ PATH=\u0026#34;\u0026#34; cat file.txt bash: cat: No such file or directory Normally your $PATH variable will include the standard locations for Linux programs - folders such as /bin, /sbin, /usr/bin and so on2.\nIf you were to print the variable, you'd see a bunch of paths (they are separated by colons; I've put them on separate lines for readability):\n/usr/local/bin /usr/bin /bin /usr/sbin /sbin The shell will start with the earlier locations and move to the later ones. This allows local flavours of tools to be installed for users, which will take precedence over general versions of tools.\nThere will likely be other locations too - you might see Java folders, package manager folders and so on.\nExecutables - Scripts Imagine we create a text file called dog in the local folder:\n#!/bin/sh echo \u0026#34;🐶 woof 🐶\u0026#34; If we make the file executable, by running chmod +x dog3, then we can run this just like any other program - as long as we tell the shell to look for programs in the current directory:\n$ PATH=\u0026#34;.\u0026#34; dog 🐶 woof 🐶 More common would be to run the program by giving a path:\n$ ./dog 🐶 woof 🐶 Or just move it to a standard location that the shell already checks for programs:\n$ mv dog /usr/local/bin $ dog 🐶 woof 🐶 The point is that executables don't have to be compiled program code. If a file starts with #! (the \u0026lsquo;shebang\u0026rsquo;), then the system will try to run the contents of the file with the program specified in the shebang.\nWe will look at shebangs in greater detail in a later chapter.\nBuiltins OK, so we've seen executables. What about a command like this?\nlocal V=\u0026#34;hello\u0026#34; echo $V You will not find the local executable anywhere on your system. It is a builtin - a special command built directly into the shell program.\nBuiltins are often highly specific to your shell. They might be used for programming (local for example is used to declare a locally scoped variable), or they might be for very shell-specific features.\nThis is where we need to take note. As soon as you are running a builtin, you are potentially using a feature that is specific to your shell, rather than a program that is shared across the system and can be run by any shell.\nTrying to programmatically execute local as a process will fail - there is no executable with that name; it is purely a shell construct.\nSo how do we know if a command is a builtin? The preferred method is to use the type command:\n$ type local local is a shell builtin The type command (which is itself a builtin!) can tell you the exact type of shell command.\nInterestingly, you might be using more builtins than you think. echo is a program, but most of the time you are not executing it when you are in a shell:\n$ type -a echo echo is a shell builtin echo is /bin/echo By using the -a flag on type to show all commands that match the name, we see that echo is actually both a builtin and a program.\nMany simple programs have builtin versions. The shell can execute them much faster.\nSome commands are a builtin so that they can function in a sensible manner. The cd command changes the current directory - if we executed it as a process, it would change only the directory for the cd process itself, not the shell, making it much less useful.\nBuiltins will vary from shell to shell, but many shells are \u0026lsquo;Bash-like\u0026rsquo; - meaning they will have a set very similar to the Bash builtins, which you can see here:\nhttps://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html\nAs should be familiar from Part 3: Getting Help, you can get help for builtins:\n$ man source # source is a builtin BUILTIN(1) BSD General Commands Manual BUILTIN(1) NAME builtin, !, %, # ...snip... SYNOPSIS builtin [-options] [args ...] However, the manual will not show information on specific builtins, which is a pain. Your shell might have an option to show more details - for example, in Bash you can use help:\n$ help source source: source filename [arguments] Read and execute commands from FILENAME and return. The pathnames in $PATH are used to find the directory containing FILENAME. If any ARGUMENTS are supplied, they become the positional parameters when FILENAME is executed. But remember: help is a builtin; you might not find it in all shells (you won't find it in zsh, for example). This highlights again the challenges of builtins.\nFunctions You can define your own shell functions. We will see a lot more of this later, but let's show a quick example for now:\n$ restart-shell () { exec -l $SHELL } This snippet creates a function that restarts the shell (quite useful if you are messing with shell configuration files or think you might have irreversibly goofed up your current session).\nWe can execute this function just like any command:\n$ restart-shell And running type will show us that this is a function:\n$ type restart-shell restart-shell is a function restart-shell () { exec -l $SHELL } Functions are one of the most powerful shell constructs we will see; they are extremely useful for building sophisticated logic. We're going to see them in a lot more detail later, but for now it is enough to know that they exist, and can run logic, and are run as commands.\nAliases An alias is just a shortcut. Type in a certain set of characters, and the shell will replace them with the value defined in the alias.\nSome common commands are actually already aliases - for example, in my zsh shell, the ls command is an alias:\n% type -a ls ls is an alias for ls -G ls is /bin/ls I make sure that when I use the ls command, the shell always expands it to ls -G, which colours the output.\nWe can quickly define aliases to save on keystrokes. For example:\n$ alias k=\u0026#39;kubectl\u0026#39; From this point on, I can use the k alias as shorthand for the kubectl command.\nAliases are far less sophisticated than functions. Think of them as keystroke savers and nothing more, and you won't go far wrong.\nSo What? So we now hopefully have a greater understanding of the variety of shell commands. Not all commands are executables, not all of the commands we think are executables necessarily are, and some commands might be more sophisticated.\nAs a shell user, the key things to remember are:\n Executables are \u0026lsquo;safe\u0026rsquo; - they are programs your system can use; your shell just calls out to them. Builtins are very shell-specific and usually control the shell itself Functions are powerful ways to write logic but will normally be shell-specific. Aliases are conveniences for human operators, but only in the context of an interactive shell.  To find out how a command is implemented, just use the type -a command:\n$ type -a cat cat is /bin/cat More than You Need to Know OK, for the masochistic few, you might be wondering about all of the other commands and utilities you may have seen that can tell you about programs and commands:\n what whatis which whence where whereis command type  A lot of these are legacy and should be avoided, but for completeness sake, we'll go through them.\nwhat what reads out special metadata embedded in a program, generally used to identify the version of source code it was built from:\n$ what /bin/ls /bin/ls Copyright (c) 1989, 1993, 1994 PROGRAM:ls PROJECT:file_cmds-272.220.1 There should be almost no circumstance in which you need to use it in your day-to-day work, but you might come across it if you meant to type whatis.\nwhatis whatis searches a local help database for text. This can be useful in tracking down manual pages:\n$ whatis bash bash(1) - GNU Bourne-Again SHell bashbug(1) - report a bug in bash But I can't imagine it will be a regularly used tool by most users.\nwhich which will search your $PATH to see whether an executable can be found. With the -a flag, it will show all results.\n$ which -a vi /usr/local/bin/vi /usr/bin/vi which originated in csh. It remains on many systems for compatibility but in general should be avoided due to potentially odd behaviour4.\nwhence whence was added to the Korn shell. You are unlikely to use it unless you are on systems using ksh. zsh also has this command, but it should be avoided and considered non-standard.\n% whence brew /usr/local/bin/brew where This is a shell builtin that can provide information on commands, similar to type:\n% where ls ls: aliased to ls -G /bin/ls However, type should be preferred, as it is more standard.\nwhereis whereis is available on some systems and generally operates the same as which, searching paths for an executable:\n% whereis ls /bin/ls Again, type should be preferred for compatability.\ncommand command is defined in the POSIX standard, so should be expected to be present on most modern systems. Without arguments, it simply executes a command. With the -v argument, you get a fairly machine-readable or processable response; with the -V argument, you get a more human readable response:\n% command -v ls alias ls=\u0026#39;ls -G\u0026#39; % command -V ls ls is an alias for ls -G command can be useful in scripts, as we will see in later chapters.\ntype type is part of the Unix standard and will be present in most modern systems. As we've already seen, it will identify the type of command as well as the location for an executable:\n% type -a ls ls is an alias for ls -G ls is /bin/ls This command can also be used to only search for paths:\n% type -p ls ls is /bin/ls Summary\nIn summary, avoid anything that starts with \u0026lsquo;w\u0026rsquo;! These are legacy commands, generally needed only when working on older Unix machines. type or command should be used instead.\n Footnotes\n  We will cover permissions and modes in later chapters. \u0026#x21a9;\u0026#xfe0e;\n Why these names and locations? It's a long story. The best place to start if you are intersted is the Filesystem Hierarchy Standard. \u0026#x21a9;\u0026#xfe0e;\n chmod changes the mode of a file; +x means \u0026lsquo;add the executable bit\u0026rsquo;. This tells the operating system the file can be executed. \u0026#x21a9;\u0026#xfe0e;\n Stack Exchange: Why not use “which”? What to use then? \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':17,'href':'/effective-shell/docs/shortcodes/','title':"Shortcodes",'content':""});index.add({'id':18,'href':'/effective-shell/docs/shortcodes/buttons/','title':"Buttons",'content':"Buttons Buttons are styled links that can lead to local page or external link.\n{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Example  Get Home  Contribute  "});index.add({'id':19,'href':'/effective-shell/docs/shortcodes/columns/','title':"Columns",'content':"Columns Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!--begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!--magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!--magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "});index.add({'id':20,'href':'/effective-shell/docs/shortcodes/expand/','title':"Expand",'content':"Expand Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample Default {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  Expand ↕  Markdown content Lorem markdownum insigne\u0026hellip;    With Custom Label {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  Custom Label ...  Markdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    "});index.add({'id':21,'href':'/effective-shell/docs/shortcodes/hints/','title':"Hints",'content':"Hints Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  "});index.add({'id':22,'href':'/effective-shell/docs/shortcodes/katex/','title':"Katex",'content':"KaTeX KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample {{\u0026lt; katex [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases} {{\u0026lt; /katex \u0026gt;}}     $$ x = \\begin{cases} a \u0026\\text{if } b \\\\ c \u0026\\text{if } d \\end{cases} $$   "});index.add({'id':23,'href':'/effective-shell/docs/shortcodes/mermaid/','title':"Mermaid",'content':"Mermaid Chart Mermaid is library for generating svg charts and diagrams from text.\nExample {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}    sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end   "});index.add({'id':24,'href':'/effective-shell/docs/shortcodes/tabs/','title':"Tabs",'content':"Tabs Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example MacOS  MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Linux  Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Windows  Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n  "});index.add({'id':25,'href':'/effective-shell/docs/','title':"Docs",'content':""});index.add({'id':26,'href':'/effective-shell/','title':"Effective Shell",'content':"Effective Shell Effective Shell is a book for anyone who uses a shell regularly. Whether you are a programmer, data scientist, reliability engineer, or just an enthusiast who loves to know how computers work, this is the book for you.\nEach chapter is designed to be independent, showing a technique or idea which will help make you more effective.\nThe first section is designed for complete newcomers; if you are an experienced user you might want to skip it.\nEach section also ends with an \u0026lsquo;interlude\u0026rsquo;, which gives a little bit of historic or interesting information about the shell, you can also skip these if you want!\n"});})();